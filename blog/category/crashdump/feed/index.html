<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>crashdump &#8211; Dev-Pro Informatique</title>
	<atom:link href="http://localhost/wordpress/category/crashdump/feed/" rel="self" type="application/rss+xml" />
	<link>http://dev-pro.xyz/blog/</link>
	<description>Solution Technologique</description>
	<lastBuildDate>Fri, 27 Dec 2019 15:50:37 +0000</lastBuildDate>
	<language>fr-CA</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.2</generator>
	<item>
		<title>Storing crash data of the Linux kernel for post-crash debugging</title>
		<link>https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:37 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[crash]]></category>
		<category><![CDATA[crashdump]]></category>
		<category><![CDATA[debug]]></category>
		<category><![CDATA[kernel]]></category>
		<category><![CDATA[kexec]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[vmcore]]></category>
		<category><![CDATA[WhitePaper]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/</guid>
				<description><![CDATA[Logging problems are key features of any complex system in order to detect and locate any unexpected behavior. On Linux system, there are lots of solutions to generate debugging information for an unexpected behavior of a userspace application (log messages,&#160;core dump). But what could we do if there is a kernel problem ? Few solutions ... <a href="https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<p>Logging problems are key features of any complex system in order to detect and locate any unexpected behavior. On Linux system, there are lots of solutions to generate debugging information for an unexpected behavior of a userspace application (log messages,&nbsp;<em>core dump</em>).</p>
<p>But what could we do if there is a kernel problem ? Few solutions exist although none are trivial.</p>
<h2 id="what-can-go-wrong-with-a-linux-kernel">What can go wrong with a Linux kernel</h2>
<p>In the first place, one can wonder what are the possible causes of kernel crashes, especially on embedded systems.</p>
<p>Here are several cases where debugging data are critical:</p>
<ol>
<li>Kernel crash due to hardware interrupt: this may be an invalid memory access, any memory-related problem (like&nbsp;DataAbort&nbsp;interrupts on ARM) or any unhandled hardware-related problem.</li>
<li>Kernel crash due to voluntary <strong>panic</strong>: the kernel code detects a problem and may trigger a&nbsp;<em>kernel panic</em>&nbsp;or a&nbsp;<em>kernel oops</em>.</li>
<li>Kernel scheduling problem: some issues with the preemption or with the execution of tasks (userspace or kernel thread).</li>
<li>Kernel deadlock: kernel is stuck due to misuses of kernel locking mechanisms like&nbsp;<em>spinlocks</em>.</li>
<li>Endless raw critical section: code disables IRQ handling and never enables it back.</li>
</ol>
<p>Except for case 5, handling all of these problems means detecting and logging a&nbsp;<em>kernel panic</em>. Generic code exists inside the kernel Linux to detect these cases and trigger a&nbsp;<em>kernel panic</em>&nbsp;when they happen. The default&nbsp;<em>DataAbort</em>&nbsp;handler causes a&nbsp;<em>kernel panic</em>. Detecting kernel deadlock could be done using the&nbsp;<a href="https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt">lockup detector</a>. Also, any non-critical error like&nbsp;<em>kernel oops</em>&nbsp;can be converted into a kernel panic using the kernel&nbsp;<em>sysctl</em>&nbsp;<code>panic_on_oops</code>&nbsp;or with the kernel boot parameter&nbsp;<code>oops=panic</code>. There is also a&nbsp;<code>panic_on_warn</code>&nbsp;parameter to trigger a&nbsp;<em>panic</em>&nbsp;when the kernel executes the&nbsp;<code>WARN()</code>&nbsp;macro.</p>
<p>One must compromise between crashing the kernel on error and the stability of the system. You should consider which is better between triggering a crash or letting the system live after this error.</p>
<p>On embedded systems, rebooting in case of unexpected behavior is often preferred to keeping on with a system which potentially does not fulfill its job.</p>
<p>Rebooting on a kernel crash could be done:</p>
<ol>
<li>In software by setting the&nbsp;<strong>panic timeout</strong>, which is the time between a panic and the effective reboot. Its is defined in the kernel configuration&nbsp;<code>CONFIG_PANIC_TIMEOUT</code> and can also be set from kernel boot parameter.</li>
<li>In hardware using a watchdog. This will happen automatically since, after a crash, the hardware watchdog won&rsquo;t be fed anymore and it will trigger a reboot after its timeout.</li>
</ol>
<p>Ensuring that an embedded system works properly is crucial. Therefore in order to detect the problem on products&nbsp;<em>in the wild</em>&nbsp;and to debug them, all available information on the issue have to be logged persistently.</p>
<p>The first information you may want is the kernel&nbsp;<em>log buffer</em>&nbsp;(aka&nbsp;<code>dmesg</code>). Getting those information will be developed as the main subjet of this article:&nbsp;<strong>How can we log persistently debugging information between a kernel crash and a reboot ?</strong></p>
<h2 id="dumping-the-kernel-log-buffer">Dumping the kernel log buffer</h2>
<p>There is no easy way to write persistently something&nbsp;<em>just after</em>&nbsp;a kernel crash occurs. The main reason is that the kernel can&rsquo;t bet trusted to save the data into disk.</p>
<p>Depending on the physical medium used to dump the data (flash nand/nor, eMMC/SD card, SATA disk, USB disk, &hellip;), the associated&nbsp;<em>subsystem</em>&nbsp;and all the drivers used to perform a dump&nbsp;<strong>must work correctly</strong>, even after a crash, which is impossible to ensure.</p>
<p>Also, when entering in&nbsp;<code>panic()</code>, all CPU are stopped and there is no more scheduling: the kernel stays in the panic function until the machine is rebooted. This means that the necessary code to perform a write on physical medium must be&nbsp;<strong>synchronous</strong>&nbsp;and never depend on scheduler which is not the case for the normal kernel paths.</p>
<p>Imagine that you want to dump kernel log on a eMMC and the kernel crashes while a transfer is still operating. eMMC access is protected by multiple locks (in several subsystems) and the transfer tends to be as asynchronous as possible. Writing on eMMC from&nbsp;<code>panic()</code>&nbsp;would have to terminate those locks and the current transfer and then perform a synchronous write on the medium using a different code-path than the one normally used, which is usually asynchronous.</p>
<p>Despite these constraints, logging the kernel buffer could be implemented using several approaches:</p>
<ol>
<li>Log continuously the kernel log buffer to an external device:
<ul>
<li>Using the network and the&nbsp;<strong>netconsole</strong>&nbsp;driver</li>
<li>Using a serial port and the&nbsp;<strong>console</strong></li>
<li>The log is kept persistent by an external system. On deployed embedded system, this is usually not possible.</li>
</ul>
</li>
<li>Specific driver implementing synchronous write:
<ul>
<li>I found two existing drivers to perform such write:&nbsp;<strong>mtdoops</strong>&nbsp;and&nbsp;<strong>ramoops</strong>. If you are using a MTD or a NVRAM, this may be the easiest solution.</li>
<li>MTD write is perfomed synchronously using&nbsp;<code>mtd_panic_write()</code>. See file&nbsp;<a href="https://github.com/torvalds/linux/blob/master/drivers/mtd/mtdoops.c">mtdoops.c</a></li>
</ul>
</li>
<li>Auxiliary&nbsp;<em>Persistent Storage</em>&nbsp;<strong>Pstore</strong>&nbsp;support:
<ul>
<li>This kernel code allows to use non-volatile, dedicated storage to store debugging information</li>
<li>This is currently limited to&nbsp;<strong>ACPI</strong>. Two LWN articles describe the implementation:&nbsp;<a href="https://lwn.net/Articles/421297/">here</a>&nbsp;and&nbsp;<a href="https://lwn.net/Articles/434821/">here</a></li>
<li>ABRT daemon has a&nbsp;<a href="https://github.com/abrt/abrt/wiki/pstore-oops">support</a>&nbsp;for these dumps</li>
<li>Since version 243, systemd will automatically store any pstore data it finds at boot time to /var/lib/pstore</li>
</ul>
</li>
<li>Execute a new, smaller Linux system on top of the one which crashed using&nbsp;<strong>kexec</strong>
<ul>
<li>Not a well known kernel feature</li>
<li>Some userspace tools available</li>
<li>Quite difficult to implement</li>
</ul>
</li>
</ol>
<p>This article will focus on this 4th solution: using&nbsp;<strong>kexec</strong>&nbsp;feature to boot a new Linux kernel in charge of saving debug information from the initial system. Although the other solutions are easier to use, the latter one is&nbsp;<strong>generic</strong>&nbsp;and does not depends on the physical medium used. This is also often the only solution available for ARM-based systems which do not have MTD to store these dumps.</p>
<h2 id="kexec-and-crashdump-overview">Kexec and crashdump overview</h2>
<p>First of all, we will discuss about <strong>kexec</strong>. This is a feature of the Linux kernel that allows booting into another system (usually another Linux kernel) from a running one. For Desktop systems, this feature is often used to perform fast&nbsp;<em>warm</em>&nbsp;reboots after a kernel update.</p>
<p>Instead of starting a Linux kernel from a bootloader, you are starting it from Linux itself. The idea is to trigger automatically a&nbsp;<em>kexec</em>&nbsp;when a crash occurs. The new booted system would be responsible of storing all debug data on persistent memory. Here is an overview of how&nbsp;<em>kexec</em>&nbsp;can be used for our needs:</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump.png" alt="" class="wp-image-7104 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump.png 507w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump-291x300.png 291w" sizes="(max-width: 507px) 100vw, 507px"></figure>
<p>Triggering&nbsp;<em>kexec</em>&nbsp;from the&nbsp;<code>panic()</code>&nbsp;function is already implemented in the Linux kernel. A dedicated&nbsp;<em>kexec image</em>&nbsp;called&nbsp;<strong>crashdump</strong>&nbsp;can be used to boot this new kernel image when the initial system crashes. To enable it in your kernel build, you need to define the following configuration:</p>
<ul>
<li><code>CONFIG_KEXEC=y</code></li>
<li><code>CONFIG_CRASH_DUMP=y</code></li>
<li><code>CONFIG_PROC_VMCORE=y</code></li>
<li><code>CONFIG_RELOCATABLE=y</code></li>
</ul>
<p>These kernel options not only execute a new kernel on crash but also keep in memory&nbsp;<strong>useful debugging data</strong>&nbsp;which are passed to the new kernel. </p>
<p>What could be the most complete data to perform post-crash investigation ? The answer is simple: the whole volatile memory of the system (RAM). But, if we want to keep it intact while booting a new kernel (which also uses memory), we have to reserve a memory region&nbsp;<strong>from the original kernel</strong>, which means from the boot of the initial system. The picture bellow describes how this initial memory region is dedicated.</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout.png" alt="" class="wp-image-7105 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout.png 484w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout-300x198.png 300w" sizes="(max-width: 484px) 100vw, 484px"></figure>
<p>To tell the initial kernel to reserve this dedicated memory region for crashdump usage, you can use the boot parameter&nbsp;<code>crashkernel=size[KMG][@offset[KMG]]</code>&nbsp;as described in the&nbsp;<a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">documentation</a>.</p>
<p>When a Linux kernel is booted after a crash, the applications launched by the second kernel are able to access the original memory through the special file&nbsp;<code>/proc/vmcore</code>. Note that this file also contains some&nbsp;<em>metadata</em>&nbsp;to help for debug and forensics.</p>
<p>To sum up, in order to dump the whole memory on a persistent memory, we can use&nbsp;<strong>kexec</strong>&nbsp;feature and define a&nbsp;<strong>crashdump</strong>&nbsp;image which will be booted when a kernel&nbsp;<code>panic()</code>occurs. To prevent the new kernel from overwriting the memory of the crash system, a memory region dedicated to crashdump is reserved at bootime.</p>
<p>Interacting with the&nbsp;<em>kexec</em>&nbsp;kernel part from userspace is done through special&nbsp;<a href="http://man7.org/linux/man-pages/man2/kexec_load.2.html">syscalls</a>&nbsp;which are called by userspace tools provided by the&nbsp;<a href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git">kexec-tools</a> package. Make sure to use a version compatible with your kernel version.</p>
<p>The&nbsp;<code>kexec</code>&nbsp;utility can be used to load the&nbsp;<em>crashdump</em>&nbsp;kernel in memory and to define its boot parameters. It can also be used to test the kexec feature by booting on-demand to the new kernel. See the&nbsp;<a href="http://man7.org/linux/man-pages/man8/kexec.8.html">man page of kexec</a>&nbsp;for details.</p>
<p>There is also a&nbsp;<code>vmcore-dmesg</code>&nbsp;utility which can be used to extract the kernel log buffer from a&nbsp;<strong>vmcore</strong>. We will see another utility called&nbsp;<code>crash</code>&nbsp;later that can do the same thing.</p>
<h2 id="implementation-of-the-vmcore-backup">Implementation of the vmcore backup</h2>
<p>To understand what is needed to boot a new Linux kernel, you can refer to what your bootloader is doing initially. On embedded system, here is the minimal things a bootloader must do:</p>
<ol>
<li>Load the kernel binary in memory (zImage)</li>
<li>For devicetree-enabled products, load the DTB in memory (myboard.dtb)</li>
<li>Define the&nbsp;<strong>kernel boot parameters</strong>&nbsp;as described&nbsp;<a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">here</a></li>
<li>Start execution of the new kernel</li>
</ol>
<p>Note that you can define the&nbsp;<strong>root filesystem</strong>&nbsp;of a kernel using&nbsp;<code>root=[device]</code>&nbsp;boot parameter. You can also change the&nbsp;<em>init</em>&nbsp;program executed by the kernel with&nbsp;<code>init=[pgm]</code>&nbsp;parameter if you don&rsquo;t want to execute the default one&nbsp;<code>/sbin/init</code>.</p>
<p>You can choose to use a new kernel binary for crashdump or simply to use the same one. When you have chosen which kernel, devicetree and root partition to use, you can use&nbsp;<code>kexec</code>&nbsp;utility to construct a crashdump image and load it in the dedicated memory:</p>
<pre class="wp-block-code"><code>BOOTARGS="maxcpus=1 reset_devices earlyprintk root=[root partition] init=[your init]"
kexec --type zImage -p [zImage_file] --dtb=[dtb_file] --append="${BOOTARGS}"</code></pre>
<p>Note that you may want to add additional boot parameter depending on your platform. The current boot parameter of a running kernel can be seen in&nbsp;<code>/proc/cmdline</code>.</p>
<p>Then you can simulate a real kernel crash using&nbsp;<em>sysrq</em>&nbsp;(if it is enabled in your kernel):</p>
<pre class="wp-block-code"><code>echo c &gt; /proc/sysrq-trigger</code></pre>
<p>You can either boot on a complete system with a real&nbsp;<code>init</code>&nbsp;like&nbsp;<em>busybox</em>,&nbsp;<em>systemd</em>, <em>SysV</em>&nbsp;or use a minimalist init program which only perform what you want (like in initrd). To test your backup procedure, you can even spawn a shell using&nbsp;<code>init=/bin/sh</code>&nbsp;if there is one in your root partition. Note that there are some limitation in this second system:</p>
<ul>
<li>Memory is limited by the amount of RAM you have reserved using the&nbsp;<code>crashkernel</code>&nbsp;boot parameter of the first Linux. During my tests, I used 64M but it depends on your needs.</li>
<li>You only have one CPU core enabled with boot parameter&nbsp;<code>maxcpus=1</code></li>
<li>Due to small amount of RAM, be carefull not to trigger the OOM Killer !</li>
</ul>
<p>You can do anything needed to backup the&nbsp;<code>vmcore</code>&nbsp;file on your physical persistent storage which can be anything supported by your Linux kernel (eMMC, MTDs, HDD, &hellip;). Here is a sample script to mount a partition and backup the file in it:</p>
<pre class="wp-block-code"><code>mount -t proc proc /proc
mount -t [fstype] /dev/[device] /debug
dd if=/proc/vmcore of=/debug/vmcore bs=1M conv=fsync
umount /debug
sync</code></pre>
<p>Note that&nbsp;<code>conv=fsync</code>&nbsp;prevents from buffering which could lead to OOM triggers as there is not a lot of RAM available.</p>
<h2 id="using-the-vmcore-file">Using the vmcore file</h2>
<p>Once you have saved your&nbsp;<code>vmcore</code>&nbsp;file, you can investigate on what happened in the crashed system and try to find the root cause of your problem.</p>
<p>The easiest-to-use utility I found is&nbsp;<code>crash</code>. See the&nbsp;<a href="https://github.com/crash-utility/crash">github</a>&nbsp;and the&nbsp;<a href="http://people.redhat.com/anderson/crash_whitepaper/">documentation</a>.</p>
<p>Be careful to use a compiled version compatible with your architecture. If you want to build it from source:</p>
<pre class="wp-block-code"><code>git clone https://github.com/crash-utility/crash.git
cd crash
make target=[your target architecture]</code></pre>
<p>In order to use the&nbsp;<code>crash</code>&nbsp;utility, you have to provide the&nbsp;<strong>vmlinux</strong>&nbsp;file corresponding to kernel used&nbsp;<strong>during the crash</strong>&nbsp;(the one of the nominal system). Generally, embedded systems use&nbsp;<code>zImage</code>&nbsp;format, so you will also need to keep the&nbsp;<code>vmlinux</code>&nbsp;version of that kernel at compilation time.</p>
<p>Then, to use&nbsp;<code>crash</code>, just launch it with your&nbsp;<code>vmlinux</code>&nbsp;and your&nbsp;<code>vmcore</code>:</p>
<pre class="wp-block-code"><code>$ ~/tools/crash/crash vmlinux vmcore
      KERNEL: vmlinux
    DUMPFILE: vmcore
        CPUS: 2 [OFFLINE: 1]
       PANIC: "sysrq: SysRq: Trigger a crash"</code></pre>
<p>You will get a lot of useful information. Here is a list of command you can use to do offline debugging:</p>
<ul>
<li><code>log</code>: extract the kernel log buffer</li>
<li><code>bt</code>: show the backtrace</li>
<li><code>rd [addr]</code>: read memory at the given address</li>
<li><code>ps</code>: extract the process list when the crash occurs</li>
</ul>
<p>You can also use the&nbsp;<code>help</code>&nbsp;command for complete list:</p>
<pre class="wp-block-code"><code>    crash&gt; help

    *              extend         log            rd             task           
    alias          files          mach           repeat         timer          
    ascii          foreach        mod            runq           tree           
    bpf            fuser          mount          search         union          
    bt             gdb            net            set            vm             
    btop           help           p              sig            vtop           
    dev            ipcs           ps             struct         waitq          
    dis            irq            pte            swap           whatis         
    eval           kmem           ptob           sym            wr             
    exit           list           ptov           sys            q     </code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>This article has presented one solution to backup crashed product memory before rebooting. This can be useful for unstable products which are already deployed. Among all listed solutions, the&nbsp;<strong>kexec</strong>&nbsp;one is hardware-agnostic and should be usable with not-too-old kernels on various architecture (tested on ARMv7).</p>
<p>However there are two impacts on&nbsp;<em>runtime</em>&nbsp;when loading a crashdump image:</p>
<ol>
<li>You have to reserve a small amount of RAM so there is less for the nominal system</li>
<li>Rebooting after a crash may take some time if you write lots of data in slow persistent storage. Adding to the downtime of the product.</li>
</ol>
<p>The&nbsp;<strong>crashdump</strong>&nbsp;image of&nbsp;<strong>kexec</strong>&nbsp;is meant to boot a new system when the first one crashes. There are a lot of possible usecases using this feature, not only to backup debugging data.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/kernel_administration_guide/kernel_crash_dump_guide">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/kernel_administration_guide/kernel_crash_dump_guide</a></li>
<li><a href="https://events.static.linuxfound.org/slides/2011/linuxcon-japan/lcj2011_wang.pdf">https://events.static.linuxfound.org/slides/2011/linuxcon-japan/lcj2011_wang.pdf</a></li>
<li><a href="http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf">http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf</a></li>
<li><a href="https://wiki.archlinux.org/index.php/kexec">https://wiki.archlinux.org/index.php/kexec</a></li>
<li><a href="https://help.ubuntu.com/lts/serverguide/kernel-crash-dump.html">https://help.ubuntu.com/lts/serverguide/kernel-crash-dump.html</a></li>
</ul>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
