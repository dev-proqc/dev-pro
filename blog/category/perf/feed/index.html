<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>perf &#8211; Dev-Pro Informatique</title>
	<atom:link href="http://localhost/wordpress/category/perf/feed/" rel="self" type="application/rss+xml" />
	<link>http://dev-pro.xyz/blog/</link>
	<description>Solution Technologique</description>
	<lastBuildDate>Fri, 27 Dec 2019 15:50:34 +0000</lastBuildDate>
	<language>fr-CA</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.2</generator>
	<item>
		<title>FlameGraph</title>
		<link>https://dev-pro.xyz/blog/flamegraph/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:34 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[debug]]></category>
		<category><![CDATA[kernel]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[perf]]></category>
		<category><![CDATA[Technologie]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/flamegraph/</guid>
				<description><![CDATA[Introduction Les outils de profilage permettent lors de l&#8217;ex&#233;cution d&#8217;un logiciel de contr&#244;ler la liste des fonctions appel&#233;es, le temps pass&#233; dans chacune d&#8217;elle, l&#8217;utilisation des ressources processeur ou l&#8217;utilisation m&#233;moire par exemple. Sous Linux une multitude d&#8217;outils sont disponibles et si vous avez d&#233;j&#224; utilis&#233; Perf ou eBPF vous avez sans nul doute remarqu&#233; ... <a href="https://dev-pro.xyz/blog/flamegraph/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<h1>Introduction</h1>
<p> Les outils de profilage permettent lors de l&rsquo;ex&eacute;cution d&rsquo;un logiciel de contr&ocirc;ler la liste des <a href="https://fr.wikipedia.org/wiki/Fonction_informatique">fonctions</a> appel&eacute;es, le temps pass&eacute; dans chacune d&rsquo;elle, l&rsquo;utilisation des ressources <a href="https://fr.wikipedia.org/wiki/Processeur">processeur</a> ou l&rsquo;utilisation <a href="https://fr.wikipedia.org/wiki/M%C3%A9moire_(informatique)">m&eacute;moire</a> par exemple. Sous Linux une multitude d&rsquo;outils sont disponibles et si vous avez d&eacute;j&agrave; utilis&eacute; Perf ou eBPF vous avez sans nul doute remarqu&eacute; que la quantit&eacute; de log g&eacute;n&eacute;r&eacute;e peut rapidement devenir gargantuesque et donc difficilement interpr&eacute;table.</p>
<p>Cet article va vous pr&eacute;senter les FlameGraph : un outil tr&egrave;s pratique de visualisation des logs d&rsquo;applications profil&eacute;es qui a &eacute;t&eacute; d&eacute;velopp&eacute; par Brendan Gregg, ing&eacute;nieur chez Netflix et sp&eacute;cialiste de l&rsquo;analyse de performance. Les FlameGraph sont une une repr&eacute;sentation des logs de n&rsquo;importe quel outil de g&eacute;n&eacute;ration de donn&eacute;es de profiling comme eBPF et Perf qui sont &eacute;galement des traceurs d&eacute;j&agrave; introduits par les excellents articles de Jugurtha :</p>
<ul>
<li><a href="http://www.linuxembedded.fr/2018/12/les-traceurs-sous-linux-1/">http://www.linuxembedded.fr/2018/12/les-traceurs-sous-linux-1/</a>&nbsp;: introduction au tra&ccedil;age et profilage d&rsquo;applications ainsi que le principe de fonctionnement de Ftrace et ses outils front-end.</li>
<li><a href="http://www.linuxembedded.fr/2019/02/les-traceurs-sous-linux-2/">http://www.linuxembedded.fr/2019/02/les-traceurs-sous-linux-2/</a>&nbsp;: utilisation de perf, avec des exemples de commandes utiles que je vais utiliser dans cet article.</li>
<li><a href="http://www.linuxembedded.fr/2019/03/les-secrets-du-traceur-ebpf/">http://www.linuxembedded.fr/2019/03/les-secrets-du-traceur-ebpf/</a></li>
</ul>
<p>Cet article n&rsquo;est qu&rsquo;un exemple d&rsquo;utilisation des FlameGraph pr&eacute;c&eacute;d&eacute; de quelques notions. Tout le m&eacute;rite revient &eacute;videmment &agrave; Brendan Gregg. Vous pouvez retrouver son blog qui sert de r&eacute;f&eacute;rence aux m&eacute;thodes de profilage, au lien suivant : <a href="http://www.brendangregg.com/overview.html">http://www.brendangregg.com/overview.html</a></p>
<h2>G&eacute;n&eacute;ration d&rsquo;un FlameGraph on-CPU</h2>
<p>Une des mani&egrave;res de profiler une application revient &agrave; d&eacute;terminer pourquoi le CPU est occup&eacute;. Une fa&ccedil;on efficace de faire cela est le profilage par &eacute;chantillonnage&nbsp;: on envoie &agrave; une certaine fr&eacute;quence une interruption au CPU pour r&eacute;cup&eacute;rer la stack trace, l&rsquo;adresse en m&eacute;moire de l&rsquo;instruction en cours d&rsquo;ex&eacute;cution (Program Counter) ainsi que l&rsquo;adresse de la fonction. Nous allons dans notre exemple utiliser la commande Perf pour ce faire.</p>
<p>Vous pouvez installer Perf sur votre distribution via votre gestionnaire de paquet&nbsp;: linux-perf sous debian, perf sous CentOS et Arch, linux-tools sous Ubuntu&hellip; De plus si vous voulez qu&rsquo;un utilisateur non root puisse collecter des donn&eacute;es dans votre terminal courant, il est possible de modifier la valeur de la variable perf_event_paranoid&nbsp;:</p>
<pre class="wp-block-preformatted"> <strong>echo -1 &gt; /proc/sys/kernel/perf_event_paranoid</strong>.</pre>
<p>NB : les programmes que vous profilez doivent comporter des symboles de debug n&eacute;cessaires &agrave; la traduction des adresses m&eacute;moire en nom de fonction.</p>
<p>Si vous voulez profiler une application int&eacute;gr&eacute;e dans votre distribution via Yocto il faut installer la version  &laquo;&nbsp;-dbg&nbsp;&raquo; du paquet que vous souhaitez analyser. Vous pouvez &eacute;galement utiliser l&rsquo;image feature &laquo;&nbsp;dbg-pkgs&nbsp;&raquo; pour cr&eacute;er une version de votre image int&eacute;grant tous les paquets de debug ce qui peut &ecirc;tre utile pour profiler le syst&egrave;me complet.</p>
<p>Sur Debian pour installer des paquets avec les symboles de debug il faut ajouter la source <strong>deb</strong> <strong>http://debug.mirrors.debian.org/debian-debug/ buster-debug main</strong> (pour debian buster) dans votre source.list d&rsquo;apt. Apr&egrave;s &ccedil;a vous pouvez installer les paquets de debug qui ont en g&eacute;n&eacute;ral comme suffixe -dbgsym.</p>
<p>Une autre source potentielle de probl&egrave;me peut &ecirc;tre que la stack trace retourn&eacute;e est incompl&egrave;te pour les applications qui sont compil&eacute;es avec des optimisations de compilation. Dans ce cas il faut recompiler l&rsquo;application avec l&rsquo;option <strong>&ndash;</strong><strong>fno-omit-frame-pointer.</strong></p>
<p>De la m&ecirc;me mani&egrave;re il est possible que la stack trace du kernel soit incompl&egrave;te si l&rsquo;option CONFIG_FRAME_POINTER est d&eacute;sactiv&eacute;e (Kernel hacking/Compile-time-checks and compiler option)</p>
<p>La proc&eacute;dure pour g&eacute;n&eacute;rer les FlameGraph CPU est tr&egrave;s simple, il suffit dans un premier temps de lancer la commande suivante pour profiler pendant 30 secondes et &agrave; une fr&eacute;quence de 99Hz (99 interruptions par seconde) une application qui a un PID valant 12345 par exemple&nbsp;:</p>
<pre class="wp-block-preformatted"><strong>perf record -F 99 -p 12345 -g -- sleep 30</strong></pre>
<p>On peut &eacute;galement profiler le syst&egrave;me complet et donc tous les coeurs de la CPU avec l&rsquo;option -a&nbsp;:</p>
<pre class="wp-block-preformatted"><strong>perf record -F 99 -a -g -- sleep 30</strong></pre>
<p>Cela va g&eacute;n&eacute;rer un fichier perf.data qui contient les &eacute;chantillons qui peuvent &ecirc;tre lus via la commande perf report :</p>
<pre class="wp-block-preformatted"><strong>perf report -n --stdio</strong> </pre>
<p>Perf est un outil tr&egrave;s puissant mais en lan&ccedil;ant les 2 derni&egrave;res commandes sur ma machine, le rapport g&eacute;n&eacute;r&eacute; fait plus d&rsquo;un millier de lignes. Et c&rsquo;est bien l&agrave; l&rsquo;int&eacute;r&ecirc;t des FlameGraph. Ils sont tr&egrave;s facile &agrave; g&eacute;n&eacute;rer et tr&egrave;s faciles &agrave; interpr&eacute;ter rapidement.</p>
<p>Dans mon cas j&rsquo;ai g&eacute;n&eacute;r&eacute; mes Flame Graphs sur une cible dont la distribution a &eacute;t&eacute; g&eacute;n&eacute;r&eacute;e via Yocto ; voici une recette tr&egrave;s simple qui va r&eacute;cup&eacute;rer les sources du projet et les installer dans la cible&nbsp;: </p>
<pre class="wp-block-preformatted">SUMMARY = "Flamegrah Yocto recipe"
DESCRIPTION = "Flamegraph are a visualization tool for profiled application logs"
LICENSE = "CLOSED"

S = "${WORKDIR}/git"

SRC_URI = "git://github.com/brendangregg/FlameGraph.git;protocol=https"
SRCREV = "1b1c6deede9c33c5134c920bdb7a44cc5528e9a7"

RDEPENDS_flamegraph = "perl"

FILES_${PN} += "flamegraph/"
do_install() {
     install -d  ${D}/flamegraph
     install -m  0755 ${S}/*.pl ${D}/flamegraph
}</pre>
<p>Vu que rien n&rsquo;est compil&eacute; dans le projet vous pouvez &eacute;galement cloner le projet &agrave; l&rsquo;URI suivant et le copier sur la cible&nbsp;: </p>
<pre class="wp-block-preformatted"><strong>git clone https://github.com/brendangregg/FlameGraph</strong></pre>
<p>Le projet consiste en une multitude de scripts perl ainsi que des exemples de FlameGraph d&eacute;j&agrave; g&eacute;n&eacute;r&eacute;s et pr&eacute;sent&eacute;s sur le blog de Brendan Gregg. A partir d&rsquo;un fichier perf.data g&eacute;n&eacute;r&eacute; par <em>perf</em> on peut le copier dans le r&eacute;pertoire du projet et lancer la commande suivante pour g&eacute;n&eacute;rer un flamegraph :</p>
<pre class="wp-block-preformatted"><strong>perf script | ./stackcollapse-perf.pl &gt; out.perf-folded &amp;&amp; ./flamegraph.pl out.perf-folded &gt; flamegraph.svg</strong> </pre>
<ul>
<li>perf script va chercher dans le r&eacute;pertoire local un fichier perf.data (g&eacute;n&eacute;r&eacute; par perf record) et afficher la trace. Attention n&eacute;anmoins cette commande est d&eacute;pendante de l&rsquo;architecture de la plateforme. Il faut donc g&eacute;n&eacute;rer les Flamegraph directement sur la cible.</li>
<li>stackcollapse-perf va formater la trace en une seule ligne pour qu&rsquo;elle puisse &ecirc;tre trait&eacute;e par le script flamegraph.pl</li>
<li>flamegraph.pl transforme le fichier out.perf-folded en une image de flamegraph.</li>
</ul>
<p>On g&eacute;n&egrave;re donc un fichier SVG qui peut facilement &ecirc;tre ouvert depuis un navigateur. Je vais vous pr&eacute;senter ici un exemple tr&egrave;s simple de FlameGraph issu d&rsquo;un petit programme.</p>
<p>D&rsquo;une part le programme va dans un premier thread ouvrir un fichier, &eacute;crire dedans, le refermer en boucle et va dans un autre thread lancer une boucle vide qui va faire mouliner le processeur. Si on profile le syst&egrave;me entier pendant 60 secondes et qu&rsquo;on lance pendant cette p&eacute;riode le programme pendant 30 secondes on obtient le r&eacute;sultat suivant&nbsp;:</p>
<figure class="wp-block-image is-resized"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-1024x633.png" alt="" class="wp-image-6947 img-fluid" width="827" height="511" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-1024x633.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-300x186.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-768x475.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_.png 1250w" sizes="(max-width: 827px) 100vw, 827px"></figure>
<p>Interpr&eacute;tation du r&eacute;sultat&nbsp;:</p>
<ul>
<li>Chaque boite repr&eacute;sente l&rsquo;appel &agrave; une fonction dans la pile</li>
<li>L&rsquo;axe des ordonn&eacute;es pr&eacute;sente la profondeur de la pile</li>
<li>La largeur des frame en abscisse correspond au temps pass&eacute; (nombre d&rsquo;&eacute;chantillons) par un CPU &agrave; ex&eacute;cuter la fonction correspondante.</li>
</ul>
<p>Dans notre cas il est tr&egrave;s facile de d&eacute;celer les t&acirc;ches gourmandes en CPU. Pour interpr&eacute;ter un Flame Graph on va chercher les boites larges tout en haut de la pile et voir par quelles fonctions elles ont &eacute;t&eacute; appel&eacute;es. Ici on remarque que la case &laquo;&nbsp;cpu_moulineur&nbsp;&raquo; est extr&ecirc;mement large, c&rsquo;est elle qui correspond &agrave; la fonction contenant une boucle vide.</p>
<p>Si on positionne le curseur de la souris sur la boite &laquo;&nbsp;cpu_moulineur&nbsp;&raquo;&nbsp;un champ affiche le nombre d&rsquo;&eacute;chantillons (et donc le temps pass&eacute; dans la fonction) ainsi que le pourcentage correspondant par rapport &agrave; la mesure compl&egrave;te.</p>
<p>Le bloc situ&eacute; &agrave; sa droite correspond &agrave; la fonction qui ouvre et ferme un fichier en boucle. En plus d&rsquo;observer le nombre d&rsquo;&eacute;chantillons pour chaque boite, il est int&eacute;ressant de voir l&rsquo;encha&icirc;nement des fonctions appel&eacute;es de l&rsquo;userspace jusqu&rsquo;aux strates les plus enfouies du kernel.</p>
<p>Ici l&rsquo;exemple est relativement trivial mais dans un plus gros projet cela peut s&rsquo;av&eacute;rer tr&egrave;s utile car les FlameGraph offrent une vision globale des fonctions appel&eacute;es par une application&nbsp;! On peut voir par exemple si l&rsquo;appel &agrave; une fonction userspace provoque l&rsquo;appel &agrave; un kmalloc c&ocirc;t&eacute; kernel.</p>
<p>NB&nbsp;: on ne sait n&eacute;anmoins pas &agrave; quel moment les fonctions sont appel&eacute;es car il n&rsquo;y a pas de notion temporelle dans les flamegraph CPU.</p>
<h1>D&rsquo;autres types de FlameGraph int&eacute;ressants</h1>
<h2>FlameGraph off-CPU</h2>
<p>Les FlameGraph on-CPU permettent de comprendre l&rsquo;usage CPU mais ne permettent pas de voir les probl&egrave;mes de latence pr&eacute;sents quand un thread est en attente d&rsquo;une I/O bloqu&eacute;e, d&rsquo;un timer ou quand il y a un changement de contexte. Cela constitue une forme d&rsquo;analyse &agrave; part enti&egrave;re que Brendan Gregg appelle analyse off-CPU (en opposition &agrave; on-CPU).</p>
<p>En r&eacute;sum&eacute; l&rsquo;analyse off-CPU est un moyen de localiser de la latence introduite par le blocage de thread, cette analyse est compl&eacute;mentaire &agrave; l&rsquo;analyse on-CPU et est n&eacute;cessaire &agrave; la compr&eacute;hension du cycle de vie d&rsquo;un thread.</p>
<p>Leur g&eacute;n&eacute;ration peut &ecirc;tre r&eacute;alis&eacute;e via le script offcputime de bcc (je vous renvoie vers l&rsquo;article de Jugurtha) qui permet de trouver pourquoi et pendant combien de temps un thread est bloqu&eacute; et ce quelque soit le type de blocage.</p>
<p>Une approche est de tracer les appels aux fonctions malloc et free et afficher sur un Flame Graph le nombre de fois o&ugrave; les fonctions ont a &eacute;t&eacute; appel&eacute;es ou le nombre de bytes qui ont &eacute;t&eacute; allou&eacute;s pour chaque frame.</p>
<h1>Conclusion</h1>
<p>En r&eacute;sum&eacute; le Flame Graph est un puissant outil de visualisation de logs d&rsquo;outils d&rsquo;analyse de performance qui peut vous permettre de gagner un temps pr&eacute;cieux. J&rsquo;ai simplement voulu vous partager cette d&eacute;couverte dans cet article qui n&rsquo;est qu&rsquo;une rapide pr&eacute;sentation, je vous invite une nouvelle fois &agrave; vous rendre sur le blog de Brendan Gregg pour beaucoup plus de d&eacute;tails !</p>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
