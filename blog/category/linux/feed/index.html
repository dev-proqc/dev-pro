<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Linux &#8211; Dev-Pro Informatique</title>
	<atom:link href="http://localhost/wordpress/category/linux/feed/" rel="self" type="application/rss+xml" />
	<link>http://dev-pro.xyz/blog/</link>
	<description>Solution Technologique</description>
	<lastBuildDate>Fri, 27 Dec 2019 15:50:37 +0000</lastBuildDate>
	<language>fr-CA</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.2</generator>
	<item>
		<title>Storing crash data of the Linux kernel for post-crash debugging</title>
		<link>https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:37 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[crash]]></category>
		<category><![CDATA[crashdump]]></category>
		<category><![CDATA[debug]]></category>
		<category><![CDATA[kernel]]></category>
		<category><![CDATA[kexec]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[vmcore]]></category>
		<category><![CDATA[WhitePaper]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/</guid>
				<description><![CDATA[Logging problems are key features of any complex system in order to detect and locate any unexpected behavior. On Linux system, there are lots of solutions to generate debugging information for an unexpected behavior of a userspace application (log messages,&#160;core dump). But what could we do if there is a kernel problem ? Few solutions ... <a href="https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<p>Logging problems are key features of any complex system in order to detect and locate any unexpected behavior. On Linux system, there are lots of solutions to generate debugging information for an unexpected behavior of a userspace application (log messages,&nbsp;<em>core dump</em>).</p>
<p>But what could we do if there is a kernel problem ? Few solutions exist although none are trivial.</p>
<h2 id="what-can-go-wrong-with-a-linux-kernel">What can go wrong with a Linux kernel</h2>
<p>In the first place, one can wonder what are the possible causes of kernel crashes, especially on embedded systems.</p>
<p>Here are several cases where debugging data are critical:</p>
<ol>
<li>Kernel crash due to hardware interrupt: this may be an invalid memory access, any memory-related problem (like&nbsp;DataAbort&nbsp;interrupts on ARM) or any unhandled hardware-related problem.</li>
<li>Kernel crash due to voluntary <strong>panic</strong>: the kernel code detects a problem and may trigger a&nbsp;<em>kernel panic</em>&nbsp;or a&nbsp;<em>kernel oops</em>.</li>
<li>Kernel scheduling problem: some issues with the preemption or with the execution of tasks (userspace or kernel thread).</li>
<li>Kernel deadlock: kernel is stuck due to misuses of kernel locking mechanisms like&nbsp;<em>spinlocks</em>.</li>
<li>Endless raw critical section: code disables IRQ handling and never enables it back.</li>
</ol>
<p>Except for case 5, handling all of these problems means detecting and logging a&nbsp;<em>kernel panic</em>. Generic code exists inside the kernel Linux to detect these cases and trigger a&nbsp;<em>kernel panic</em>&nbsp;when they happen. The default&nbsp;<em>DataAbort</em>&nbsp;handler causes a&nbsp;<em>kernel panic</em>. Detecting kernel deadlock could be done using the&nbsp;<a href="https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt">lockup detector</a>. Also, any non-critical error like&nbsp;<em>kernel oops</em>&nbsp;can be converted into a kernel panic using the kernel&nbsp;<em>sysctl</em>&nbsp;<code>panic_on_oops</code>&nbsp;or with the kernel boot parameter&nbsp;<code>oops=panic</code>. There is also a&nbsp;<code>panic_on_warn</code>&nbsp;parameter to trigger a&nbsp;<em>panic</em>&nbsp;when the kernel executes the&nbsp;<code>WARN()</code>&nbsp;macro.</p>
<p>One must compromise between crashing the kernel on error and the stability of the system. You should consider which is better between triggering a crash or letting the system live after this error.</p>
<p>On embedded systems, rebooting in case of unexpected behavior is often preferred to keeping on with a system which potentially does not fulfill its job.</p>
<p>Rebooting on a kernel crash could be done:</p>
<ol>
<li>In software by setting the&nbsp;<strong>panic timeout</strong>, which is the time between a panic and the effective reboot. Its is defined in the kernel configuration&nbsp;<code>CONFIG_PANIC_TIMEOUT</code> and can also be set from kernel boot parameter.</li>
<li>In hardware using a watchdog. This will happen automatically since, after a crash, the hardware watchdog won&rsquo;t be fed anymore and it will trigger a reboot after its timeout.</li>
</ol>
<p>Ensuring that an embedded system works properly is crucial. Therefore in order to detect the problem on products&nbsp;<em>in the wild</em>&nbsp;and to debug them, all available information on the issue have to be logged persistently.</p>
<p>The first information you may want is the kernel&nbsp;<em>log buffer</em>&nbsp;(aka&nbsp;<code>dmesg</code>). Getting those information will be developed as the main subjet of this article:&nbsp;<strong>How can we log persistently debugging information between a kernel crash and a reboot ?</strong></p>
<h2 id="dumping-the-kernel-log-buffer">Dumping the kernel log buffer</h2>
<p>There is no easy way to write persistently something&nbsp;<em>just after</em>&nbsp;a kernel crash occurs. The main reason is that the kernel can&rsquo;t bet trusted to save the data into disk.</p>
<p>Depending on the physical medium used to dump the data (flash nand/nor, eMMC/SD card, SATA disk, USB disk, &hellip;), the associated&nbsp;<em>subsystem</em>&nbsp;and all the drivers used to perform a dump&nbsp;<strong>must work correctly</strong>, even after a crash, which is impossible to ensure.</p>
<p>Also, when entering in&nbsp;<code>panic()</code>, all CPU are stopped and there is no more scheduling: the kernel stays in the panic function until the machine is rebooted. This means that the necessary code to perform a write on physical medium must be&nbsp;<strong>synchronous</strong>&nbsp;and never depend on scheduler which is not the case for the normal kernel paths.</p>
<p>Imagine that you want to dump kernel log on a eMMC and the kernel crashes while a transfer is still operating. eMMC access is protected by multiple locks (in several subsystems) and the transfer tends to be as asynchronous as possible. Writing on eMMC from&nbsp;<code>panic()</code>&nbsp;would have to terminate those locks and the current transfer and then perform a synchronous write on the medium using a different code-path than the one normally used, which is usually asynchronous.</p>
<p>Despite these constraints, logging the kernel buffer could be implemented using several approaches:</p>
<ol>
<li>Log continuously the kernel log buffer to an external device:
<ul>
<li>Using the network and the&nbsp;<strong>netconsole</strong>&nbsp;driver</li>
<li>Using a serial port and the&nbsp;<strong>console</strong></li>
<li>The log is kept persistent by an external system. On deployed embedded system, this is usually not possible.</li>
</ul>
</li>
<li>Specific driver implementing synchronous write:
<ul>
<li>I found two existing drivers to perform such write:&nbsp;<strong>mtdoops</strong>&nbsp;and&nbsp;<strong>ramoops</strong>. If you are using a MTD or a NVRAM, this may be the easiest solution.</li>
<li>MTD write is perfomed synchronously using&nbsp;<code>mtd_panic_write()</code>. See file&nbsp;<a href="https://github.com/torvalds/linux/blob/master/drivers/mtd/mtdoops.c">mtdoops.c</a></li>
</ul>
</li>
<li>Auxiliary&nbsp;<em>Persistent Storage</em>&nbsp;<strong>Pstore</strong>&nbsp;support:
<ul>
<li>This kernel code allows to use non-volatile, dedicated storage to store debugging information</li>
<li>This is currently limited to&nbsp;<strong>ACPI</strong>. Two LWN articles describe the implementation:&nbsp;<a href="https://lwn.net/Articles/421297/">here</a>&nbsp;and&nbsp;<a href="https://lwn.net/Articles/434821/">here</a></li>
<li>ABRT daemon has a&nbsp;<a href="https://github.com/abrt/abrt/wiki/pstore-oops">support</a>&nbsp;for these dumps</li>
<li>Since version 243, systemd will automatically store any pstore data it finds at boot time to /var/lib/pstore</li>
</ul>
</li>
<li>Execute a new, smaller Linux system on top of the one which crashed using&nbsp;<strong>kexec</strong>
<ul>
<li>Not a well known kernel feature</li>
<li>Some userspace tools available</li>
<li>Quite difficult to implement</li>
</ul>
</li>
</ol>
<p>This article will focus on this 4th solution: using&nbsp;<strong>kexec</strong>&nbsp;feature to boot a new Linux kernel in charge of saving debug information from the initial system. Although the other solutions are easier to use, the latter one is&nbsp;<strong>generic</strong>&nbsp;and does not depends on the physical medium used. This is also often the only solution available for ARM-based systems which do not have MTD to store these dumps.</p>
<h2 id="kexec-and-crashdump-overview">Kexec and crashdump overview</h2>
<p>First of all, we will discuss about <strong>kexec</strong>. This is a feature of the Linux kernel that allows booting into another system (usually another Linux kernel) from a running one. For Desktop systems, this feature is often used to perform fast&nbsp;<em>warm</em>&nbsp;reboots after a kernel update.</p>
<p>Instead of starting a Linux kernel from a bootloader, you are starting it from Linux itself. The idea is to trigger automatically a&nbsp;<em>kexec</em>&nbsp;when a crash occurs. The new booted system would be responsible of storing all debug data on persistent memory. Here is an overview of how&nbsp;<em>kexec</em>&nbsp;can be used for our needs:</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump.png" alt="" class="wp-image-7104 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump.png 507w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/crashdump-291x300.png 291w" sizes="(max-width: 507px) 100vw, 507px"></figure>
<p>Triggering&nbsp;<em>kexec</em>&nbsp;from the&nbsp;<code>panic()</code>&nbsp;function is already implemented in the Linux kernel. A dedicated&nbsp;<em>kexec image</em>&nbsp;called&nbsp;<strong>crashdump</strong>&nbsp;can be used to boot this new kernel image when the initial system crashes. To enable it in your kernel build, you need to define the following configuration:</p>
<ul>
<li><code>CONFIG_KEXEC=y</code></li>
<li><code>CONFIG_CRASH_DUMP=y</code></li>
<li><code>CONFIG_PROC_VMCORE=y</code></li>
<li><code>CONFIG_RELOCATABLE=y</code></li>
</ul>
<p>These kernel options not only execute a new kernel on crash but also keep in memory&nbsp;<strong>useful debugging data</strong>&nbsp;which are passed to the new kernel. </p>
<p>What could be the most complete data to perform post-crash investigation ? The answer is simple: the whole volatile memory of the system (RAM). But, if we want to keep it intact while booting a new kernel (which also uses memory), we have to reserve a memory region&nbsp;<strong>from the original kernel</strong>, which means from the boot of the initial system. The picture bellow describes how this initial memory region is dedicated.</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout.png" alt="" class="wp-image-7105 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout.png 484w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/memory_layout-300x198.png 300w" sizes="(max-width: 484px) 100vw, 484px"></figure>
<p>To tell the initial kernel to reserve this dedicated memory region for crashdump usage, you can use the boot parameter&nbsp;<code>crashkernel=size[KMG][@offset[KMG]]</code>&nbsp;as described in the&nbsp;<a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">documentation</a>.</p>
<p>When a Linux kernel is booted after a crash, the applications launched by the second kernel are able to access the original memory through the special file&nbsp;<code>/proc/vmcore</code>. Note that this file also contains some&nbsp;<em>metadata</em>&nbsp;to help for debug and forensics.</p>
<p>To sum up, in order to dump the whole memory on a persistent memory, we can use&nbsp;<strong>kexec</strong>&nbsp;feature and define a&nbsp;<strong>crashdump</strong>&nbsp;image which will be booted when a kernel&nbsp;<code>panic()</code>occurs. To prevent the new kernel from overwriting the memory of the crash system, a memory region dedicated to crashdump is reserved at bootime.</p>
<p>Interacting with the&nbsp;<em>kexec</em>&nbsp;kernel part from userspace is done through special&nbsp;<a href="http://man7.org/linux/man-pages/man2/kexec_load.2.html">syscalls</a>&nbsp;which are called by userspace tools provided by the&nbsp;<a href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git">kexec-tools</a> package. Make sure to use a version compatible with your kernel version.</p>
<p>The&nbsp;<code>kexec</code>&nbsp;utility can be used to load the&nbsp;<em>crashdump</em>&nbsp;kernel in memory and to define its boot parameters. It can also be used to test the kexec feature by booting on-demand to the new kernel. See the&nbsp;<a href="http://man7.org/linux/man-pages/man8/kexec.8.html">man page of kexec</a>&nbsp;for details.</p>
<p>There is also a&nbsp;<code>vmcore-dmesg</code>&nbsp;utility which can be used to extract the kernel log buffer from a&nbsp;<strong>vmcore</strong>. We will see another utility called&nbsp;<code>crash</code>&nbsp;later that can do the same thing.</p>
<h2 id="implementation-of-the-vmcore-backup">Implementation of the vmcore backup</h2>
<p>To understand what is needed to boot a new Linux kernel, you can refer to what your bootloader is doing initially. On embedded system, here is the minimal things a bootloader must do:</p>
<ol>
<li>Load the kernel binary in memory (zImage)</li>
<li>For devicetree-enabled products, load the DTB in memory (myboard.dtb)</li>
<li>Define the&nbsp;<strong>kernel boot parameters</strong>&nbsp;as described&nbsp;<a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">here</a></li>
<li>Start execution of the new kernel</li>
</ol>
<p>Note that you can define the&nbsp;<strong>root filesystem</strong>&nbsp;of a kernel using&nbsp;<code>root=[device]</code>&nbsp;boot parameter. You can also change the&nbsp;<em>init</em>&nbsp;program executed by the kernel with&nbsp;<code>init=[pgm]</code>&nbsp;parameter if you don&rsquo;t want to execute the default one&nbsp;<code>/sbin/init</code>.</p>
<p>You can choose to use a new kernel binary for crashdump or simply to use the same one. When you have chosen which kernel, devicetree and root partition to use, you can use&nbsp;<code>kexec</code>&nbsp;utility to construct a crashdump image and load it in the dedicated memory:</p>
<pre class="wp-block-code"><code>BOOTARGS="maxcpus=1 reset_devices earlyprintk root=[root partition] init=[your init]"
kexec --type zImage -p [zImage_file] --dtb=[dtb_file] --append="${BOOTARGS}"</code></pre>
<p>Note that you may want to add additional boot parameter depending on your platform. The current boot parameter of a running kernel can be seen in&nbsp;<code>/proc/cmdline</code>.</p>
<p>Then you can simulate a real kernel crash using&nbsp;<em>sysrq</em>&nbsp;(if it is enabled in your kernel):</p>
<pre class="wp-block-code"><code>echo c &gt; /proc/sysrq-trigger</code></pre>
<p>You can either boot on a complete system with a real&nbsp;<code>init</code>&nbsp;like&nbsp;<em>busybox</em>,&nbsp;<em>systemd</em>, <em>SysV</em>&nbsp;or use a minimalist init program which only perform what you want (like in initrd). To test your backup procedure, you can even spawn a shell using&nbsp;<code>init=/bin/sh</code>&nbsp;if there is one in your root partition. Note that there are some limitation in this second system:</p>
<ul>
<li>Memory is limited by the amount of RAM you have reserved using the&nbsp;<code>crashkernel</code>&nbsp;boot parameter of the first Linux. During my tests, I used 64M but it depends on your needs.</li>
<li>You only have one CPU core enabled with boot parameter&nbsp;<code>maxcpus=1</code></li>
<li>Due to small amount of RAM, be carefull not to trigger the OOM Killer !</li>
</ul>
<p>You can do anything needed to backup the&nbsp;<code>vmcore</code>&nbsp;file on your physical persistent storage which can be anything supported by your Linux kernel (eMMC, MTDs, HDD, &hellip;). Here is a sample script to mount a partition and backup the file in it:</p>
<pre class="wp-block-code"><code>mount -t proc proc /proc
mount -t [fstype] /dev/[device] /debug
dd if=/proc/vmcore of=/debug/vmcore bs=1M conv=fsync
umount /debug
sync</code></pre>
<p>Note that&nbsp;<code>conv=fsync</code>&nbsp;prevents from buffering which could lead to OOM triggers as there is not a lot of RAM available.</p>
<h2 id="using-the-vmcore-file">Using the vmcore file</h2>
<p>Once you have saved your&nbsp;<code>vmcore</code>&nbsp;file, you can investigate on what happened in the crashed system and try to find the root cause of your problem.</p>
<p>The easiest-to-use utility I found is&nbsp;<code>crash</code>. See the&nbsp;<a href="https://github.com/crash-utility/crash">github</a>&nbsp;and the&nbsp;<a href="http://people.redhat.com/anderson/crash_whitepaper/">documentation</a>.</p>
<p>Be careful to use a compiled version compatible with your architecture. If you want to build it from source:</p>
<pre class="wp-block-code"><code>git clone https://github.com/crash-utility/crash.git
cd crash
make target=[your target architecture]</code></pre>
<p>In order to use the&nbsp;<code>crash</code>&nbsp;utility, you have to provide the&nbsp;<strong>vmlinux</strong>&nbsp;file corresponding to kernel used&nbsp;<strong>during the crash</strong>&nbsp;(the one of the nominal system). Generally, embedded systems use&nbsp;<code>zImage</code>&nbsp;format, so you will also need to keep the&nbsp;<code>vmlinux</code>&nbsp;version of that kernel at compilation time.</p>
<p>Then, to use&nbsp;<code>crash</code>, just launch it with your&nbsp;<code>vmlinux</code>&nbsp;and your&nbsp;<code>vmcore</code>:</p>
<pre class="wp-block-code"><code>$ ~/tools/crash/crash vmlinux vmcore
      KERNEL: vmlinux
    DUMPFILE: vmcore
        CPUS: 2 [OFFLINE: 1]
       PANIC: "sysrq: SysRq: Trigger a crash"</code></pre>
<p>You will get a lot of useful information. Here is a list of command you can use to do offline debugging:</p>
<ul>
<li><code>log</code>: extract the kernel log buffer</li>
<li><code>bt</code>: show the backtrace</li>
<li><code>rd [addr]</code>: read memory at the given address</li>
<li><code>ps</code>: extract the process list when the crash occurs</li>
</ul>
<p>You can also use the&nbsp;<code>help</code>&nbsp;command for complete list:</p>
<pre class="wp-block-code"><code>    crash&gt; help

    *              extend         log            rd             task           
    alias          files          mach           repeat         timer          
    ascii          foreach        mod            runq           tree           
    bpf            fuser          mount          search         union          
    bt             gdb            net            set            vm             
    btop           help           p              sig            vtop           
    dev            ipcs           ps             struct         waitq          
    dis            irq            pte            swap           whatis         
    eval           kmem           ptob           sym            wr             
    exit           list           ptov           sys            q     </code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>This article has presented one solution to backup crashed product memory before rebooting. This can be useful for unstable products which are already deployed. Among all listed solutions, the&nbsp;<strong>kexec</strong>&nbsp;one is hardware-agnostic and should be usable with not-too-old kernels on various architecture (tested on ARMv7).</p>
<p>However there are two impacts on&nbsp;<em>runtime</em>&nbsp;when loading a crashdump image:</p>
<ol>
<li>You have to reserve a small amount of RAM so there is less for the nominal system</li>
<li>Rebooting after a crash may take some time if you write lots of data in slow persistent storage. Adding to the downtime of the product.</li>
</ol>
<p>The&nbsp;<strong>crashdump</strong>&nbsp;image of&nbsp;<strong>kexec</strong>&nbsp;is meant to boot a new system when the first one crashes. There are a lot of possible usecases using this feature, not only to backup debugging data.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/kernel_administration_guide/kernel_crash_dump_guide">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/kernel_administration_guide/kernel_crash_dump_guide</a></li>
<li><a href="https://events.static.linuxfound.org/slides/2011/linuxcon-japan/lcj2011_wang.pdf">https://events.static.linuxfound.org/slides/2011/linuxcon-japan/lcj2011_wang.pdf</a></li>
<li><a href="http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf">http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf</a></li>
<li><a href="https://wiki.archlinux.org/index.php/kexec">https://wiki.archlinux.org/index.php/kexec</a></li>
<li><a href="https://help.ubuntu.com/lts/serverguide/kernel-crash-dump.html">https://help.ubuntu.com/lts/serverguide/kernel-crash-dump.html</a></li>
</ul>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Gestion de versions des bibliothèques partagées</title>
		<link>https://dev-pro.xyz/blog/gestion-de-versions-des-bibliotheques-partagees/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:35 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[libc]]></category>
		<category><![CDATA[linker]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[symboles]]></category>
		<category><![CDATA[WhitePaper]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/gestion-de-versions-des-bibliotheques-partagees/</guid>
				<description><![CDATA[Tout code est susceptible au changement, avec pour objectif d&#8217;ajouter des fonctionnalit&#233;s, de r&#233;soudre des BUGS ou m&#234;me d&#8217;aller jusqu&#8217;a modifier les interfaces (alt&#233;rer les prototypes des fonctions). G&#233;n&#233;ralement plus un code est utilis&#233; par la communaut&#233;, plus il est d&#233;conseill&#233; de modifier les interfaces lors d&#8217;une &#233;volution. Cependant, la r&#233;trocompatibilit&#233; reste floue pour certains ... <a href="https://dev-pro.xyz/blog/gestion-de-versions-des-bibliotheques-partagees/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<p>Tout code est susceptible au changement, avec pour objectif d&rsquo;ajouter des fonctionnalit&eacute;s, de r&eacute;soudre des BUGS ou m&ecirc;me d&rsquo;aller jusqu&rsquo;a modifier les interfaces (<em>alt&eacute;rer les prototypes des fonctions</em>).</p>
<p>G&eacute;n&eacute;ralement plus un code est utilis&eacute; par la communaut&eacute;, plus il est d&eacute;conseill&eacute; de modifier les interfaces lors d&rsquo;une &eacute;volution. Cependant, la r&eacute;trocompatibilit&eacute; reste floue pour certains d&eacute;veloppeurs surtout lors de la mise &agrave; jour des <strong>biblioth&egrave;ques partag&eacute;es</strong>.</p>
<p>Dans cet article, nous d&eacute;couvrirons comment maintenir les biblioth&egrave;ques pour pouvoir les distribuer et les modifier sans avoir &agrave; recompiler les anciens binaires.  Ces derniers pourront ainsi b&eacute;n&eacute;ficier d&rsquo;une am&eacute;lioration de performances ou de corrections de failles de s&eacute;curit&eacute;.</p>
<h2>Pourquoi la gestion de version des biblioth&egrave;ques?</h2>
<p>Pour r&eacute;pondre &agrave; cette question il est important de conna&icirc;tre quelques concepts li&eacute;s aux biblioth&egrave;ques partag&eacute;es. </p>
<h3>Quelques conventions &agrave; retenir</h3>
<ul>
<li>Une biblioth&egrave;que partag&eacute;e doit &ecirc;tre compil&eacute;e comme ceci :</li>
</ul>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #996633">$ </span>gcc -Wall -fPIC -c bibliotheque_dynamique.c
<span style="color: #996633">$ </span>gcc -shared bibliotheque_dynamique.o -o bibliotheque_dynamique.so
</pre>
</div>
<p>L&rsquo;argument  &laquo;&nbsp;-shared&nbsp;&raquo; est un flag linker utilis&eacute; pour cr&eacute;er les biblioth&egrave;ques partag&eacute;es.</p>
<p><strong>Remarque :</strong> le flag du compilateur &laquo;&nbsp;-fPIC&nbsp;&raquo; ne doit pas &ecirc;tre associ&eacute; &agrave; la cr&eacute;ation des biblioth&egrave;ques partag&eacute;es (<em>il est possible de l&rsquo;utiliser pour cr&eacute;er des biblioth&egrave;ques statiques</em>).</p>
<ul>
<li>Par convention, le nom d&rsquo;une biblioth&egrave;que partag&eacute;e prend la forme : <strong>lib</strong>nombibliotheque<strong>.so.&lt;M&gt;.&lt;m&gt;.&lt;p&gt;</strong> (par exemple : <em>libssl</em>.<em>so</em>.1.0.0).</li>
</ul>
<p><strong>N.B :</strong> les symboles <strong>M</strong>, <strong>m</strong> et <strong>p</strong> d&eacute;signent les nombres <strong>M</strong>ajeur, <strong>m</strong>ineur et <strong>p</strong>atch respectivement. Ces derniers pr&eacute;cisent l&rsquo;impact du changement de version sur le code, par exemple : la modification de la signature d&rsquo;une fonction est un changement de type majeur alors que l&rsquo;optimisation d&rsquo;un calcul dans une routine a des cons&eacute;quences mineures.</p>
<h3>Alors pourquoi versionner?</h3>
<p>Pour d&eacute;montrer l&rsquo;importance du versionnage, nous allons cr&eacute;er une simple biblioth&egrave;que partag&eacute;e (<em>et suivre son &eacute;volution</em>). </p>
<h4>Exemple pratique</h4>
<p>Pour les besoins d&rsquo;un outil de monitoring du syst&egrave;me, nous impl&eacute;mentons une biblioth&egrave;que qui permet de lister les diff&eacute;rents utilisateurs connect&eacute;s sur le syst&egrave;me.</p>
<h4>Solution propos&eacute;e</h4>
<p>Sous Linux, il existe deux fichiers qui se chargent de cette t&acirc;che :</p>
<ul>
<li><strong>/var/run/utmp :</strong> qui liste les utilisateurs connect&eacute;s (<em>utilis&eacute; par l&rsquo;utilitaire who</em>).</li>
<li><strong>/var/log/wtmp :</strong> sauvegarde chaque connexion et d&eacute;connexion &eacute;tablie par un utilisateur (<em>utilis&eacute; par l&rsquo;utilitaire &laquo;&nbsp;last&nbsp;&raquo;</em>). </li>
</ul>
<h4>Premi&egrave;re release : libusrmgr.so.1.0.0</h4>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/no_method_build_fail/libusrmgr.so.1.0.0/usrmgr.h">usrmgr.h</a> : fichier header de la biblioth&egrave;que &laquo;&nbsp;<strong>libusrmgr.so.1.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;utmpx.h&gt;</span>
<span style="color: #557799">#include &lt;time.h&gt;</span>

<span style="color: #888888">/* Retourne la liste des utilisateurs connect&eacute;s */</span>
<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getLoggedUsers</span>();
</pre>
</div>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/no_method_build_fail/libusrmgr.so.1.0.0/usrmgr.c">usrmgr.c :</a> impl&eacute;mentation de la biblioth&egrave;que &laquo;&nbsp;<strong>libusrmgr.so.1.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "usrmgr.h"</span>

<span style="color: #888888">/* Retourne la liste des utilisateurs connect&eacute;s */</span>
<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getLoggedUsers</span>(){
    <span style="color: #008800;font-weight: bold">struct</span> utmpx <span style="color: #333333">*</span>utmpUser;

    setutxent(); <span style="color: #888888">// Ouverture du fichier /var/run/utmp</span>

    <span style="color: #888888">/* Parcours de la liste des utilisateurs */</span>
    <span style="color: #008800;font-weight: bold">while</span> ((utmpUser <span style="color: #333333">=</span> getutxent()) <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>) {
        printf(<span style="background-color: #fff0f0">"Utilisateur : %s &lt;=&gt; PID : %ld at : %s"</span>, utmpUser<span style="color: #333333">-&gt;</span>ut_user,
         (<span style="color: #333399;font-weight: bold">long</span>) utmpUser<span style="color: #333333">-&gt;</span>ut_pid, ctime((<span style="color: #333399;font-weight: bold">time_t</span> <span style="color: #333333">*</span>) <span style="color: #333333">&amp;</span>(utmpUser<span style="color: #333333">-&gt;</span>ut_tv.tv_sec)));
    }
}
</pre>
</div>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/lib_build_ko/old_binary/oldBinary.c">premierBinaire.c :</a> binaire client (qui va utiliser notre biblioth&egrave;que partag&eacute;e).</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "usrmgr.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(){
    printf(<span style="background-color: #fff0f0">"La liste des utilisateurs connect&eacute;s : </span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>);
    getLoggedUsers();

    <span style="color: #008800;font-weight: bold">return</span> EXIT_SUCCESS;
}
</pre>
</div>
<p>Il ne reste plus qu&rsquo;&agrave; r&eacute;aliser la compilation et le test :</p>
<ul>
<li>Compiler une biblioth&egrave;que partag&eacute;e :</li>
</ul>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #996633">$ </span>gcc -Wall -fPIC -c usrmgr.c
<span style="color: #996633">$ </span>gcc -shared usrmgr.o -o libusrmgr.so.1.0.0
</pre>
</div>
<ul>
<li>Compiler le binaire et tester l&rsquo;ex&eacute;cution :</li>
</ul>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/users_listed.png" alt="" data-id="6876" data-link="http://www.linuxembedded.fr/?attachment_id=6876" class="wp-image-6876 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/users_listed.png 746w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/users_listed-300x74.png 300w" sizes="(max-width: 746px) 100vw, 746px"></figure>
</li>
</ul>
<h4>Deuxi&egrave;me release : libusrmgr.so.2.0.0</h4>
<p>Au fil du temps, on se rend compte des besoins suivants :</p>
<ul>
<li>Le fichier utmp (<em>ouvert avec setutxent()</em>) n&rsquo;est pas ferm&eacute; apr&egrave;s avoir obtenu la liste des utilisateurs (<em>l&rsquo;ancien binaire doit b&eacute;n&eacute;ficier de cette mise &agrave; jour</em>).</li>
<li>Pour des raisons de s&eacute;curit&eacute;, l&rsquo;utilisateur &laquo;&nbsp;Pierre&nbsp;&raquo; ne doit pas &ecirc;tre affich&eacute; (<em>l&rsquo;ancien binaire doit b&eacute;n&eacute;ficier de cette mise &agrave; jour</em>).</li>
<li>La fonction <strong>getLoggedUsers</strong>() doit retourner le nombre d&rsquo;utilisateurs. Pour cela l&rsquo;ABI de la fonction doit changer (<em>obligation de passer &agrave; la version 2.0.0 de la biblioth&egrave;que</em>).</li>
<li>Introduire la possibilit&eacute; de filtrer sur un seul utilisateur.</li>
</ul>
<p>Avec ce simple exemple, on se retrouve contraint de maintenir plusieurs versions de la biblioth&egrave;que, ce qui n&rsquo;est pas possible (<em>les anciens binaires ne vont b&eacute;n&eacute;ficier d&rsquo;aucune mise &agrave; jour</em>). </p>
<p>La prochaine release (<em>incompatible avec l&rsquo;ancien binaire</em>) sera comme ceci :</p>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/no_method_build_fail/libusrmgr.so.2.0.0/usrmgr.h">usrmgr.h :</a> fichier header de la biblioth&egrave;que &laquo;&nbsp;<strong>libusrmgr.so.2.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;utmpx.h&gt;</span>
<span style="color: #557799">#include &lt;time.h&gt;</span>
<span style="color: #557799">#include &lt;string.h&gt;</span>

<span style="color: #557799">#define HIDDEN_USER "Pierre"</span>

<span style="color: #888888">/* Affiche et retourne le nombre des utilisateurs connect&eacute;s */</span>
<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getLoggedUsers</span>(<span style="color: #333399;font-weight: bold">char</span> filterUser[]);
</pre>
</div>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/no_method_build_fail/libusrmgr.so.2.0.0/usrmgr.c">usrmgr.c :</a> impl&eacute;mentation de la biblioth&egrave;que &laquo;&nbsp;<strong>libusrmgr.so.2.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "usrmgr.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getLoggedUsers</span>(<span style="color: #333399;font-weight: bold">char</span> filterUser[]){
    <span style="color: #333399;font-weight: bold">int</span> usr_nb <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    <span style="color: #008800;font-weight: bold">struct</span> utmpx <span style="color: #333333">*</span>utmpUser;
    setutxent(); <span style="color: #888888">// Ouverture du fichier /var/run/utmp</span>

    <span style="color: #888888">/* Parcours de la liste des utilisateurs */</span>
    <span style="color: #008800;font-weight: bold">while</span> ((utmpUser <span style="color: #333333">=</span> getutxent()) <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>) {
        <span style="color: #008800;font-weight: bold">if</span>(strcmp(utmpUser<span style="color: #333333">-&gt;</span>ut_user, HIDDEN_USER) <span style="color: #333333">==</span> <span style="color: #0000DD;font-weight: bold">0</span>){
            <span style="color: #888888">// Reprendre au d&eacute;but de la boucle pour ne pas inclure l'utilisateur.</span>
            <span style="color: #008800;font-weight: bold">continue</span>;
        }
        usr_nb<span style="color: #333333">++</span>;
        <span style="color: #008800;font-weight: bold">if</span>(strcmp(utmpUser<span style="color: #333333">-&gt;</span>ut_user,filterUser) <span style="color: #333333">==</span> <span style="color: #0000DD;font-weight: bold">0</span>){ <span style="color: #888888">// Si filtre utilisateur</span>
             printf(<span style="background-color: #fff0f0">"Filtre utilisateur : %s &lt;=&gt; PID : %ld at : %s est connect&eacute;!</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>,
                utmpUser<span style="color: #333333">-&gt;</span>ut_user, (<span style="color: #333399;font-weight: bold">long</span>) utmpUser<span style="color: #333333">-&gt;</span>ut_pid,
                ctime((<span style="color: #333399;font-weight: bold">time_t</span> <span style="color: #333333">*</span>) <span style="color: #333333">&amp;</span>(utmpUser<span style="color: #333333">-&gt;</span>ut_tv.tv_sec)));
            <span style="color: #008800;font-weight: bold">break</span>;
        } <span style="color: #008800;font-weight: bold">else</span> <span style="color: #008800;font-weight: bold">if</span>(strcmp(filterUser,<span style="background-color: #fff0f0">""</span>) <span style="color: #333333">==</span> <span style="color: #0000DD;font-weight: bold">0</span>){
             printf(<span style="background-color: #fff0f0">"Utilisateur : %s &lt;=&gt; PID : %ld at : %s</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, utmpUser<span style="color: #333333">-&gt;</span>ut_user,
                (<span style="color: #333399;font-weight: bold">long</span>) utmpUser<span style="color: #333333">-&gt;</span>ut_pid, ctime((<span style="color: #333399;font-weight: bold">time_t</span> <span style="color: #333333">*</span>) <span style="color: #333333">&amp;</span>(utmpUser<span style="color: #333333">-&gt;</span>ut_tv.tv_sec)));
        }
    }

    endutxent(); <span style="color: #888888">// Fermer le fichier /var/run/utmp</span>
    <span style="color: #008800;font-weight: bold">return</span> usr_nb;
}
</pre>
</div>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/no_method_build_fail/libusrmgr.so.2.0.0/deuxiemeBinaire.c">deuxiemeBinaire.c :</a> le binaire doit &ecirc;tre mis &agrave; jour comme ceci :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "usrmgr.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(){
    printf(<span style="background-color: #fff0f0">"La liste des utilisateurs connect&eacute;s : </span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>);
    getLoggedUsers(<span style="background-color: #fff0f0">""</span>);

    printf(<span style="background-color: #fff0f0">"</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">Filtrer sur l'utilisateur 'jugurtha' : </span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>);
    getLoggedUsers(<span style="background-color: #fff0f0">"jugurtha"</span>);

    <span style="color: #008800;font-weight: bold">return</span> EXIT_SUCCESS;
}
</pre>
</div>
<p>La compilation et l&rsquo;ex&eacute;cution du nouveau binaire sont r&eacute;alis&eacute;es comme suit :</p>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_fail_to.png" alt="" data-id="7052" data-link="https://www.linuxembedded.fr/?attachment_id=7052" class="wp-image-7052 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_fail_to.png 798w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_fail_to-300x148.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_fail_to-768x378.png 768w" sizes="(max-width: 798px) 100vw, 798px"></figure>
</li>
</ul>
<p>Il est temps d&rsquo;essayer d&rsquo;ex&eacute;cuter l&rsquo;ancien binaire (<em>qu&rsquo;il faut copier dans le r&eacute;pertoire ou se trouve libusrmgr.so.2.0.0</em>) avec la nouvelle biblioth&egrave;que :</p>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/failed_to_load_previous_lib.png" alt="" data-id="7053" data-link="https://www.linuxembedded.fr/?attachment_id=7053" class="wp-image-7053 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/failed_to_load_previous_lib.png 797w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/failed_to_load_previous_lib-300x24.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/failed_to_load_previous_lib-768x61.png 768w" sizes="(max-width: 797px) 100vw, 797px"></figure>
</li>
</ul>
<div style="text-align:center;background-color:#6DD5FA11;padding : 2px">
<h3 style="text-align:center;font-weight:bold">Important</h3>
<p>L&rsquo;utilitaire <strong>ldd</strong> permet de lister les biblioth&egrave;ques import&eacute;es par une application. Voici le r&eacute;sultat de la commande sur nos deux programmes :
</p>
<div style="text-align:center">
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/ldd_shows_lib_failure.png" alt="" class="wp-image-7073 img-fluid" width="95%" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/ldd_shows_lib_failure.png 804w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/ldd_shows_lib_failure-300x81.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/ldd_shows_lib_failure-768x206.png 768w" sizes="(max-width: 804px) 100vw, 804px"></figure>
</div>
<p>On peut voir clairement que le chemin vers la biblioth&egrave;que &laquo;&nbsp;libusrmgr.so.1.0.0&nbsp;&raquo; n&rsquo;est pas <br />r&eacute;solu (<em>pour le premier binaire</em>). </p>
</div>
<p style="text-align:center"><span style="color:red">C&rsquo;est cela qu&rsquo;on appelle le probl&egrave;me de version des biblioth&egrave;ques partag&eacute;es. </span><strong>Une notion m&eacute;connue de certains d&eacute;veloppeurs.</strong></p>
<h2>G&eacute;rer le versionnement de ses biblioth&egrave;ques</h2>
<p>Il existe deux m&eacute;thodes tr&egrave;s appr&eacute;ci&eacute;es en pratique :</p>
<ul>
<li><strong>M&eacute;thode du lien symbolique de type &laquo;&nbsp;soname&nbsp;&raquo; :</strong> se limite aux changements mineurs et aux patchs (<em>donc les nombres mineur et patch d&rsquo;une version d&rsquo;une biblioth&egrave;que</em>).</li>
<li><strong>M&eacute;thode &laquo;&nbsp;gestion de symboles&nbsp;&raquo; :</strong> plus puissante (<em>et un peu plus complexe</em>) que la pr&eacute;c&eacute;dente mais permet de g&eacute;rer tout type de changement en gardant une r&eacute;trocompabilit&eacute; irr&eacute;prochable (<em>r&eacute;siste m&ecirc;me au changement de l&rsquo;ABI et des interfaces</em>). C&rsquo;est cette m&eacute;thode qu&rsquo;utilise la fameuse biblioth&egrave;que <a href="https://akkadia.org/drepper/symbol-versioning">glibc</a>.</li>
</ul>
<h3>La m&eacute;thode du lien type &laquo;&nbsp;soname&nbsp;&raquo;</h3>
<p>Cette m&eacute;thode part du principe de r&eacute;duction des informations de versionnage qui apparaissent dans le nom des biboth&egrave;ques partag&eacute;es.</p>
<p>Pour cela le binaire est compil&eacute; avec un lien symbolique interm&eacute;diaire (<em>appel&eacute; le lien &laquo;&nbsp;soname&nbsp;&raquo;</em>) qui ne contient que le nombre majeur comme information de versionnage (<em>qui lui m&ecirc;me fait r&eacute;f&eacute;rence &agrave; la vraie biblioth&egrave;que</em>). La figure suivante illustre le processus :</p>
<ul class="wp-block-gallery columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-1.png" alt="" data-id="6821" data-link="http://www.linuxembedded.fr/?attachment_id=6821" class="wp-image-6821 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-1.png 881w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-1-300x157.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-1-768x403.png 768w" sizes="(max-width: 881px) 100vw, 881px"></figure>
</li>
</ul>
<p>Comme le montre clairement le sch&eacute;ma pr&eacute;c&eacute;dent, plus besoin de recompiler le binaire pour r&eacute;f&eacute;rencer la nouvelle version de la biblioth&egrave;que. On peut encore aller plus loin, un lien symbolique (<em>optionnel mais recommand&eacute; par convention</em>) peut &ecirc;tre ins&eacute;r&eacute; entre le binaire et le lien symbolique de type soname. Cela permet de compiler le binaire d&rsquo;une mani&egrave;re g&eacute;n&eacute;rique : <code>$ gcc -ltestbiblio</code> &hellip; &agrave; la place de <code>$ gcc -l:libtestbiblio.so.1.</code></p>
<p>Le sch&eacute;ma final qui d&eacute;crit la m&eacute;thode soname est le suivant :</p>
<ul class="wp-block-gallery columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-based_method-1.png" alt="" data-id="6824" data-link="http://www.linuxembedded.fr/?attachment_id=6824" class="wp-image-6824 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-based_method-1.png 976w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-based_method-1-300x197.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/soname-based_method-1-768x504.png 768w" sizes="(max-width: 976px) 100vw, 976px"></figure>
</li>
</ul>
<p>Ce qui fait maintenant que tous les binaires (<em>tant que le nombre majeur n&rsquo;est pas chang&eacute;</em>) peuvent fonctionner avec la nouvelle biblioth&egrave;que sans avoir &agrave; les recompiler.</p>
<h4>Exemple 1 : release de la biblioth&egrave;que libfilemanager.so.1.0.0</h4>
<p>Nous prendrons comme exemple une simple biblioth&egrave;que qui affiche les statistiques d&rsquo;un fichier.</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.0.0/filemanager.h">filemanager.h</a> :</strong> header de la biblioth&egrave;que <strong>&laquo;&nbsp;libfilemanager.so.1.0.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;sys/types.h&gt;</span>
<span style="color: #557799">#include &lt;sys/stat.h&gt;</span>
<span style="color: #557799">#include &lt;unistd.h&gt;</span>
<span style="color: #557799">#include &lt;stdio.h&gt;</span>

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFileStats</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> filePath);
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.0.0/filemanager.c">filemanager.c</a> :</strong> impl&eacute;mentation de la biblioth&egrave;que <strong>&laquo;&nbsp;filemanager.so.1.0.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "filemanager.h"</span>

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFileStats</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> filePath){
    <span style="color: #008800;font-weight: bold">struct</span> stat fileStat;
    <span style="color: #333399;font-weight: bold">int</span> fileError <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    
    fileError <span style="color: #333333">=</span> stat(filePath, <span style="color: #333333">&amp;</span>fileStat);

    <span style="color: #008800;font-weight: bold">if</span>(fileError <span style="color: #333333">&lt;</span> <span style="color: #0000DD;font-weight: bold">0</span>){
        perror(<span style="background-color: #fff0f0">"erreur fonction stat"</span>);
        <span style="color: #008800;font-weight: bold">return</span>;
    }
    <span style="color: #888888">// Check if the provided file is a regular file</span>
    <span style="color: #008800;font-weight: bold">if</span>((fileStat.st_mode <span style="color: #333333">&amp;</span> S_IFMT) <span style="color: #333333">==</span> S_IFREG)
        printf(<span style="background-color: #fff0f0">"Nom du Fichier %s =&gt; Taille : %ld bytes</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, filePath, fileStat.st_size);
    <span style="color: #008800;font-weight: bold">else</span>
        printf(<span style="background-color: #fff0f0">"Le fichier n'est pas de type S_IFREG</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>);
}
</pre>
</div>
<p>La compilation et la cr&eacute;ation du lien symbolique doivent se faire comme ceci :</p>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_compilation-1.png" alt="" data-id="6708" data-link="http://www.linuxembedded.fr/?attachment_id=6708" class="wp-image-6708 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_compilation-1.png 878w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_compilation-1-300x32.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_compilation-1-768x83.png 768w" sizes="(max-width: 878px) 100vw, 878px"></figure>
</li>
</ul>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.0.0/premierClient.c">premierClient.c :</a></strong> impl&eacute;mentation du binaire client <strong>&laquo;&nbsp;premierClient&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "filemanager.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(<span style="color: #333399;font-weight: bold">int</span> argc, <span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span>argv[]){
    
    <span style="color: #008800;font-weight: bold">if</span>(argc <span style="color: #333333">&lt;</span><span style="color: #0000DD;font-weight: bold">2</span>){
        printf(<span style="background-color: #fff0f0">"Usage : %s &lt;Nom_Fichier&gt;</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, argv[<span style="color: #0000DD;font-weight: bold">0</span>]);
        <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">1</span>;    
    }
    <span style="color: #888888">// Get file statistics        </span>
    getFileStats(argv[<span style="color: #0000DD;font-weight: bold">1</span>]);

    <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">0</span>;
}
</pre>
</div>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_client_compilation_mode.png" alt="" class="wp-image-6710 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_client_compilation_mode.png 879w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_client_compilation_mode-300x54.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/soname_client_compilation_mode-768x137.png 768w" sizes="(max-width: 879px) 100vw, 879px"></figure>
</div>
<h4>Exemple 2 : release de la biblioth&egrave;que libfilemanager.so.1.1.0</h4>
<p>Apr&egrave;s quelque temps, on se rend compte qu&rsquo;il est n&eacute;cessaire d&rsquo;avoir une fonction pour lister les fichiers contenus dans un dossier, on doit introduire l&rsquo;interface <strong>&laquo;&nbsp;getFilesInFolder</strong>&nbsp;&raquo; et faire une nouvelle release <strong>&laquo;&nbsp;libfilemanager.so.1.1.0&nbsp;&raquo;</strong>.</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.1.0/filemanager.h">filemanager.h :</a></strong> header de la biblioth&egrave;que <strong>&laquo;&nbsp;libfilemanager.so.1.1.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;sys/types.h&gt;</span>
<span style="color: #557799">#include &lt;sys/stat.h&gt;</span>
<span style="color: #557799">#include &lt;unistd.h&gt;</span>
<span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;dirent.h&gt;</span>

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFileStats</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> filePath);

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFilesInFolder</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> folderPath);
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.1.0/filemanager.c">filemanager.c :</a></strong> impl&eacute;mentation de la biblioth&egrave;que <strong>&laquo;&nbsp;filemanager.so.1.1.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "filemanager.h"</span>

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFileStats</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> filePath){
    <span style="color: #008800;font-weight: bold">struct</span> stat fileStat;
    <span style="color: #333399;font-weight: bold">int</span> fileError <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    
    fileError <span style="color: #333333">=</span> stat(filePath, <span style="color: #333333">&amp;</span>fileStat);

    <span style="color: #008800;font-weight: bold">if</span>(fileError <span style="color: #333333">&lt;</span> <span style="color: #0000DD;font-weight: bold">0</span>){
        perror(<span style="background-color: #fff0f0">"erreur fonction stat"</span>);
        <span style="color: #008800;font-weight: bold">return</span>;
    }
    <span style="color: #888888">// Check if the provided file is a regular file</span>
    <span style="color: #008800;font-weight: bold">if</span>((fileStat.st_mode <span style="color: #333333">&amp;</span> S_IFMT) <span style="color: #333333">==</span> S_IFREG)
        printf(<span style="background-color: #fff0f0">"Nom du Fichier %s =&gt; Taille : %ld bytes</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, filePath, fileStat.st_size);
    <span style="color: #008800;font-weight: bold">else</span>
        printf(<span style="background-color: #fff0f0">"Le fichier n'est pas de type S_IFREG</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>);
}

<span style="color: #333399;font-weight: bold">void</span> <span style="color: #0066BB;font-weight: bold">getFilesInFolder</span>(<span style="color: #008800;font-weight: bold">const</span> <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> folderPath){
    <span style="color: #333399;font-weight: bold">DIR</span><span style="color: #333333">*</span> folder <span style="color: #333333">=</span> <span style="color: #007020">NULL</span>;
    <span style="color: #008800;font-weight: bold">struct</span> dirent<span style="color: #333333">*</span> fileToRead <span style="color: #333333">=</span> <span style="color: #007020">NULL</span>;
    <span style="color: #333399;font-weight: bold">int</span> fileCounter <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;

    folder <span style="color: #333333">=</span> opendir(folderPath); <span style="color: #888888">// open folder</span>

    <span style="color: #008800;font-weight: bold">if</span> (folder <span style="color: #333333">==</span> <span style="color: #007020">NULL</span>){
        perror(<span style="background-color: #fff0f0">"Fonction opendir"</span>);
        <span style="color: #008800;font-weight: bold">return</span>;
    }
    
    <span style="color: #008800;font-weight: bold">while</span> ((fileToRead <span style="color: #333333">=</span> readdir(folder)) <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>){
        fileCounter<span style="color: #333333">++</span>;
        <span style="color: #888888">// display discovered files</span>
        printf(<span style="background-color: #fff0f0">"%d - %s</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, fileCounter, fileToRead<span style="color: #333333">-&gt;</span>d_name);
    }

    closedir(folder);
}
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/soname_method/libfilemanager.so.1.1.0/dexiemeClient.c">deuxiemeClient.c :</a></strong> impl&eacute;mentation du binaire client <strong>&laquo;&nbsp;deuxiemeClient&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "filemanager.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(<span style="color: #333399;font-weight: bold">int</span> argc, <span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span>argv[]){
    
    <span style="color: #008800;font-weight: bold">if</span>(argc <span style="color: #333333">&lt;</span><span style="color: #0000DD;font-weight: bold">2</span>){
        printf(<span style="background-color: #fff0f0">"Usage : %s &lt;Nom_Dossier&gt;</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, argv[<span style="color: #0000DD;font-weight: bold">0</span>]);
        <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">1</span>;
    }
            
    getFilesInFolder(argv[<span style="color: #0000DD;font-weight: bold">1</span>]);

    <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">0</span>;
}
</pre>
</div>
<ul>
<li>Supprimer l&rsquo;ancien lien symbolique :</li>
</ul>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #996633">$ </span>rm -rf libfilemanager.so
</pre>
</div>
<ul>
<li>Recompiler la biblioth&egrave;que et cr&eacute;er un nouveau lien de type &laquo;&nbsp;soname&nbsp;&raquo; comme d&eacute;crit pr&eacute;c&eacute;demment (<em>exemple 1</em>). </li>
</ul>
<ul>
<li>Compiler le binaire client :</li>
</ul>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_name_method_minor_number.png" alt="" data-id="7054" data-link="https://www.linuxembedded.fr/?attachment_id=7054" class="wp-image-7054 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_name_method_minor_number.png 757w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_name_method_minor_number-300x134.png 300w" sizes="(max-width: 757px) 100vw, 757px"></figure>
</li>
</ul>
<p><strong>N.B :</strong> L&rsquo;ancien binaire ne sera pas affect&eacute; par les changements, le loader va toujours charger libfilemanager.so.1 (<em>qui pointe d&eacute;sormais sur libfilemanager.1.1.0</em>) comme le montre la figure ci-dessous : </p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_backward_compatible.png" alt="" class="wp-image-7055 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_backward_compatible.png 757w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/soname_backward_compatible-300x185.png 300w" sizes="(max-width: 757px) 100vw, 757px"></figure>
<p>La m&eacute;thode <strong>&laquo;&nbsp;soname&nbsp;&raquo;</strong> nous a permis en toute facilit&eacute; d&rsquo;apporter des modifications &agrave; notre bilbioth&egrave;que, le tout en restant compatible avec l&rsquo;ancien binaire.</p>
<h3>La m&eacute;thode &laquo;&nbsp;gestion de symboles&nbsp;&raquo;</h3>
<p>Cette m&eacute;thode est plus puissante et plus compl&egrave;te que la pr&eacute;c&eacute;dente (<em>elle est</em> <em>d&rsquo;ailleurs utilis&eacute;e par glibc depuis la version 2.6</em>). En effet, les changements ne sont pas restreints au nombre mineur (<em>et nombre patch</em>) d&rsquo;une biblioth&egrave;que.<br />La m&eacute;thode &laquo;&nbsp;gestion de symboles&nbsp;&raquo; s&rsquo;appuie aussi sur la m&eacute;thode du lien du type &laquo;&nbsp;soname&nbsp;&raquo; en garantissant une r&eacute;trocompatibilit&eacute; ant&eacute;rieure pour tout type de modifications.<br />Le sch&eacute;ma vu pr&eacute;c&eacute;demment peut &ecirc;tre red&eacute;fini comme suit :</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/10/soname-based_method-2.png" alt="" class="wp-image-6986 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/soname-based_method-2.png 976w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/soname-based_method-2-300x197.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/soname-based_method-2-768x504.png 768w" sizes="(max-width: 976px) 100vw, 976px"></figure>
</div>
<p><strong>N.B :</strong> il n&rsquo;est plus n&eacute;c&eacute;ssaire d&rsquo;avoir un lien symbolique (<em>entre le binaire et le lien de type &laquo;&nbsp;soname&nbsp;&raquo;</em>) car le nom du lien type &laquo;&nbsp;soname&nbsp;&raquo; ne contient plus le nombre majeur.</p>
<p>La m&eacute;thode &laquo;&nbsp;gestion de symboles&nbsp;&raquo; introduit deux briques suppl&eacute;mentaires pour combler les limitations de la m&eacute;thode du lien type &laquo;&nbsp;soname&nbsp;&raquo; :</p>
<ul>
<li><strong>Le gestionnaire de version &laquo;&nbsp;linker script&nbsp;&raquo; :</strong> fichier pars&eacute; par le linker; ce dernier d&eacute;crit les fonctions, leurs versions (<em>en indiquant la version &agrave; utiliser pour les anciennes et les prochaines versions de la biblioth&egrave;que</em>) et  leur visibilit&eacute; (<em>les fonctions &agrave; exporter au binaire du client</em>).<br /><strong>N.B :</strong> le gestionnaire de version est suffisant pour g&eacute;rer les changements sur les nombres mineur et patch.</li>
<li><strong>la directive &laquo;&nbsp;.symver&nbsp;&raquo; (<em>directive support&eacute;e par GCC</em>) :</strong> utilis&eacute;e lors d&rsquo;une alt&eacute;ration du prototype d&rsquo;une fonction (<em>incluant une mise &agrave; jour du nombre majeur de la biblioth&egrave;que</em>).<br /><strong>N.B :</strong> cette directive n&rsquo;est introduite que lors d&rsquo;un changement de la d&eacute;finition des interfaces (<em>c&rsquo;est &agrave; dire la mise &agrave; jour du nombre majeur</em>).</li>
</ul>
<p>Comme dans le cas des parties pr&eacute;c&eacute;dentes, nous partirons sur un exemple qui va &eacute;voluer au fur et &agrave; mesure.</p>
<h4>Exemple 1 : premi&egrave;re release de la biblioth&egrave;que libnbgenerator.so.1.0.0</h4>
<p>Pour les besoins d&rsquo;une gestion de mot de passe, nous impl&eacute;mentons une biblioth&egrave;que qui peut g&eacute;n&eacute;rer des nombres pseudo-al&eacute;atoires. </p>
<p>Une simple impl&eacute;mentation peut &ecirc;tre la suivante :</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/first_client/nbgenerator.h">nbgenerator.h :</a></strong> header de la biblioth&egrave;que <strong>&laquo;&nbsp;libnbgenerator.so.1.0.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;time.h&gt;</span>

<span style="color: #557799">#define DEFAULT_MAX_NUMBER_LIMIT 1000</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit);
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/first_client/nbgenerator.c">nbgenerator.c :</a></strong> impl&eacute;mentation de la biblioth&egrave;que &laquo;&nbsp;<strong>libnbgenerator.so.1.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit){
    <span style="color: #333399;font-weight: bold">int</span> rNumber <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    srand(time(<span style="color: #007020">NULL</span>));
    <span style="color: #008800;font-weight: bold">if</span>(numLimit <span style="color: #333333">&gt;</span> <span style="color: #0000DD;font-weight: bold">0</span>)
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> numLimit;
    <span style="color: #008800;font-weight: bold">else</span>
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> DEFAULT_MAX_NUMBER_LIMIT;
    <span style="color: #008800;font-weight: bold">return</span> rNumber;
}
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/first_client/script_version">script_version :</a></strong> et enfin le &laquo;&nbsp;linker script&nbsp;&raquo; pour assister le linker &agrave; la cr&eacute;ation d&rsquo;une biblioth&egrave;que conforme &agrave; la m&eacute;thode &laquo;&nbsp;gestion de symboles&nbsp;&raquo;. Dans ce cas, il indique que seul <strong>getPseudoNumber</strong> sera export&eacute; et vu par le binaire du client.</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%">NBGENERATOR_1.0<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getPseudoNumber;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;
</pre>
</div>
<p><strong>N.B :</strong> g&eacute;n&eacute;ralement il est n&rsquo;est pas n&eacute;cessaire d&rsquo;inclure le nombre patch dans le &laquo;&nbsp;linker script&nbsp;&raquo; car ce genre de changement n&rsquo;impacte pas la r&eacute;trocompatibilit&eacute; (<em>NBGENERATOR_1.0 n&rsquo;est qu&rsquo;un symbole dans l&rsquo;ent&ecirc;te de la biblioth&egrave;que comme on verra par la suite</em>) ; cependant, on peut tr&egrave;s bien &eacute;crire <strong>NBGENERATOR_1.0.0</strong>.</p>
<p>la compilation de la biblioth&egrave;que se fera de la mani&egrave;re suivante :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%">PC@PC ~ <span style="color: #996633">$ </span>gcc -Wall -fPIC -c nbgenerator.c
PC@PC ~ <span style="color: #996633">$ </span>gcc -shared nbgenerator.o -Wl,-soname,libnbgenerator.so -Wl,--version-script,script_version -o libnbgenerator.so.1.0.0
PC@PC ~ <span style="color: #996633">$ </span>ldconfig -n .
</pre>
</div>
<p><strong>Remarque :</strong> Il est obligatoire de passer &laquo;&nbsp;-Wl, option&nbsp;&raquo; comme option de compilation pour modifier le comportement du linker (<em>pour tenir compte du fichier de version &laquo;&nbsp;linker script&nbsp;&raquo;</em>).</p>
<p>Gr&acirc;ce au &laquo;&nbsp;linker script&nbsp;&raquo;, le linker ins&egrave;re 3 sections dans l&rsquo;ent&ecirc;te de la biblioth&egrave;que comme le montre la figure suivante :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #996633">$ </span>readelf -V nbgenerator.so

Version symbols section <span style="background-color: #fff0f0">'.gnu.version'</span> contains 12 entries:
 Addr: 00000000000003f2  Offset: 0x0003f2  Link: 3 <span style="color: #333333">(</span>.dynsym<span style="color: #333333">)</span>
  000:   0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>       0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>       0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>       3 <span style="color: #333333">(</span>GLIBC_2.2.5<span style="color: #333333">)</span>
  004:   0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>       3 <span style="color: #333333">(</span>GLIBC_2.2.5<span style="color: #333333">)</span>   0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>       0 <span style="color: #333333">(</span>*local*<span style="color: #333333">)</span>    
  008:   3 <span style="color: #333333">(</span>GLIBC_2.2.5<span style="color: #333333">)</span>   3 <span style="color: #333333">(</span>GLIBC_2.2.5<span style="color: #333333">)</span>   2 <span style="color: #333333">(</span>NBGENERATOR_1.0<span style="color: #333333">)</span>     2 <span style="color: #333333">(</span>NBGENERATOR_1.0<span style="color: #333333">)</span>  

Version definition section <span style="background-color: #fff0f0">'.gnu.version_d'</span> contains 2 entries:
  Addr: 0x0000000000000410  Offset: 0x000410  Link: 4 <span style="color: #333333">(</span>.dynstr<span style="color: #333333">)</span>  000000: Rev: 1  Flags: BASE   Index: 1  Cnt: 1  Name: nbgenerator.so
  0x001c: Rev: 1  Flags: none  Index: 2  Cnt: 1  Name: NBGENERATOR_1.0
  Version definition past end of section

Version needs section <span style="background-color: #fff0f0">'.gnu.version_r'</span> contains 1 entries:
 Addr: 0x0000000000000448  Offset: 0x000448  Link: 4 <span style="color: #333333">(</span>.dynstr<span style="color: #333333">)</span>
  000000: Version: 1  File: libc.so.6  Cnt: 1
  0x0010:   Name: GLIBC_2.2.5  Flags: none  Version: 3
</pre>
</div>
<ul>
<li><strong>.gnu.version :</strong> contient les informations de version globale.</li>
<li><strong>.gnu.version_d :</strong> affiche les informations de version relative &agrave; cette biblioth&egrave;que.</li>
<li><strong>.gnu.version_r :</strong> permet de suivre les informations de version relatives aux biblioth&egrave;ques r&eacute;f&eacute;renc&eacute;es par cette biblioth&egrave;que.</li>
</ul>
<p><strong>N.B :</strong> ces champs li&eacute;s &agrave; la version seront recopi&eacute;s dans le binaire du client lors de la compilation, ce qui permettra au loader de charger les bonnes versions de fonctions adapt&eacute;es pour chaque binaire.</p>
<p>La biblioth&egrave;que est pr&ecirc;te, il ne reste plus qu&rsquo;&agrave; cr&eacute;er un client pour l&rsquo;exploiter.</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/first_client/premierClient.c">premierClient.c :</a></strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/first_client/premierClient.c"> </a>premier binaire client.</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(){
    printf(<span style="background-color: #fff0f0">"Le nombre al&eacute;atoire est %d</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, getPseudoNumber(<span style="color: #0000DD;font-weight: bold">1500</span>));
    <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">0</span>;
}
</pre>
</div>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/10/first_library_version.png" alt="" class="wp-image-6972 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/first_library_version.png 1019w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/first_library_version-300x54.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/first_library_version-768x137.png 768w" sizes="(max-width: 1019px) 100vw, 1019px"></figure>
</div>
<h4>Exemple 2 : deuxi&egrave;me release de libnbgenerator.so.1.1.0</h4>
<p>En plus des nombres pseudo-al&eacute;atoires, il est requis d&rsquo;avoir une interface pour la g&eacute;n&eacute;ration de chaines de caract&egrave;res contenant des mots de passe.<br />Cela peut se faire comme indiqu&eacute; :</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/second_client/nbgenerator.h">nbgenerator.h :</a></strong> header de la biblioth&egrave;que <strong>&laquo;&nbsp;libnbgenerator.so.1.1.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;time.h&gt;</span>
<span style="color: #557799">#include &lt;string.h&gt;</span>

<span style="color: #557799">#define DEFAULT_MAX_NUMBER_LIMIT 1000</span>
<span style="color: #557799">#define MAX_PASSWORD_LENGTH 20</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit);

<span style="color: #888888">/* generationMotDePasse has a local symbol */</span>
<span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span><span style="color: #0066BB;font-weight: bold">generationMotDePasse</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);

<span style="color: #888888">/* generationMotDePasse has a global symbol (exported to client binary) */</span>
<span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/second_client/nbgenerator.c">nbgenerator.c :</a></strong>  impl&eacute;mentation de la biblioth&egrave;que &laquo;&nbsp;<strong>libnbgenerator.so.1.1.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">char</span> password[MAX_PASSWORD_LENGTH] <span style="color: #333333">=</span> {<span style="color: #0000DD;font-weight: bold">0</span>};
<span style="color: #888888">// getPseudoNumber : exported to client binary</span>
<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit){
    <span style="color: #333399;font-weight: bold">int</span> rNumber <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    srand(time(<span style="color: #007020">NULL</span>));
    <span style="color: #008800;font-weight: bold">if</span>(numLimit <span style="color: #333333">&gt;</span> <span style="color: #0000DD;font-weight: bold">0</span>)
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> numLimit;
    <span style="color: #008800;font-weight: bold">else</span>
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> DEFAULT_MAX_NUMBER_LIMIT;
    <span style="color: #008800;font-weight: bold">return</span> rNumber;
}
<span style="color: #888888">// generationMotDePasse : not exported to client binary</span>
<span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span><span style="color: #0066BB;font-weight: bold">generationMotDePasse</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters){
    <span style="color: #333399;font-weight: bold">short</span> i <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    memset(password, <span style="color: #0000DD;font-weight: bold">0</span>, MAX_PASSWORD_LENGTH);
    
    srand(time(<span style="color: #007020">NULL</span>));
    
    <span style="color: #008800;font-weight: bold">if</span>((nbCharacters <span style="color: #333333">&gt;</span> MAX_PASSWORD_LENGTH) <span style="color: #333333">||</span> (nbCharacters <span style="color: #333333">&lt;=</span> <span style="color: #0000DD;font-weight: bold">0</span>))
        nbCharacters <span style="color: #333333">=</span> MAX_PASSWORD_LENGTH;
    <span style="color: #888888">/* G&eacute;n&eacute;ration du mot de passe */</span>
    <span style="color: #008800;font-weight: bold">for</span>(i <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span> nbCharacters; i<span style="color: #333333">++</span>){
        password[i] <span style="color: #333333">=</span> <span style="color: #0044DD">'A'</span> <span style="color: #333333">+</span> (rand() <span style="color: #333333">%</span> nbCharacters);
    }
    <span style="color: #008800;font-weight: bold">return</span> password;
}
<span style="color: #888888">// getRandomPassword : exported to client binary</span>
<span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters){
    <span style="color: #008800;font-weight: bold">return</span> generationMotDePasse(nbCharacters);
}
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/second_client/script_version">script_version :</a></strong> Seules 2 des 3 fonctions seront export&eacute;es vers le binaire du client (<strong><em>getPseudoNumber()</em></strong><em> et </em><strong><em>getRandomPassword()</em></strong>) .</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%">NBGENERATOR_1.0<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getPseudoNumber;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;

NBGENERATOR_1.1<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getRandomPassword;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;
</pre>
</div>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/second_client/dexiemeClient.c">deuxiemeClient.c :</a></strong> deuxi&egrave;me version du binaire du client</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(){
    printf(<span style="background-color: #fff0f0">"Le nombre al&eacute;atoire est %d</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, getPseudoNumber(<span style="color: #0000DD;font-weight: bold">1500</span>));
    printf(<span style="background-color: #fff0f0">"Le mot de passe : %s</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, getRandomPassword(<span style="color: #0000DD;font-weight: bold">10</span>));
    <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">0</span>;
}
</pre>
</div>
<p>la compilation se fait comme indiqu&eacute; ci dessous :</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/linker_script_dynamic_library.png" alt="" class="wp-image-7057 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/linker_script_dynamic_library.png 836w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/linker_script_dynamic_library-300x120.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/linker_script_dynamic_library-768x308.png 768w" sizes="(max-width: 836px) 100vw, 836px"></figure>
<p>Il est temps de tester l&rsquo;ancien programme sans le recompiler :</p>
<ul class="wp-block-gallery columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/symbol_method_name_back_compatible.png" alt="" data-id="7058" data-link="https://www.linuxembedded.fr/?attachment_id=7058" class="wp-image-7058 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/symbol_method_name_back_compatible.png 838w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/symbol_method_name_back_compatible-300x40.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/symbol_method_name_back_compatible-768x103.png 768w" sizes="(max-width: 838px) 100vw, 838px"></figure>
</li>
</ul>
<h4>Exemple 3 : troisi&egrave;me release de libnbgenerator.so.2.0.0</h4>
<p>Il arrive parfois que la d&eacute;finition des interfaces soit modifi&eacute;e (<em>on dit souvent une alt&eacute;ration de l&rsquo;ABI</em>). Sans la m&eacute;thode &laquo;&nbsp;<strong>gestion de symboles</strong>&laquo;&nbsp;, ce genre de changement garantit de casser la r&eacute;tro-compatibilit&eacute; (<em>c&rsquo;est le cas d&rsquo;une fonction qui ne retourne plus le m&ecirc;me type ou pire encore, une interface qui doit &ecirc;tre retir&eacute;e de l&rsquo;usage dans les nouveaux binaire</em>s).</p>
<p>Dans le cas de notre biblioth&egrave;que, on se retrouve vite limit&eacute; par la fonction <strong>getRandomPassword</strong>() qui doit retourner en plus du mot de passe en clair, le <strong>mot de passe hash&eacute;</strong> et la <strong>fonction de hash</strong>. </p>
<p style="text-align:center">La question qui se pose est comment faire compiler le code suivant :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #888888">// Ancien binaire</span>
<span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);

<span style="color: #888888">// Nouveau binaire</span>
<span style="color: #008800;font-weight: bold">struct</span> PasswordHash <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);
</pre>
</div>
<p>La r&eacute;ponse est la suivante :</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/third_client/nbgenerator.h">nbgenerator.h :</a></strong> header de la biblioth&egrave;que <strong>&laquo;&nbsp;libnbgenerator.so.2.0.0&nbsp;&raquo;</strong> :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;time.h&gt;</span>
<span style="color: #557799">#include &lt;string.h&gt;</span>
<span style="color: #557799">#define _XOPEN_SOURCE</span>
<span style="color: #557799">#include &lt;unistd.h&gt;</span>
<span style="color: #557799">#include &lt;crypt.h&gt;</span>

<span style="color: #557799">#define DEFAULT_MAX_NUMBER_LIMIT 1000</span>
<span style="color: #557799">#define MAX_PASSWORD_LENGTH 20</span>
<span style="color: #557799">#define ENCRYPTION_CIPHER_METHOD "crypt"</span>

<span style="color: #008800;font-weight: bold">struct</span> PasswordHash{
    <span style="color: #333399;font-weight: bold">char</span> hashNameFunc[<span style="color: #0000DD;font-weight: bold">20</span>];
    <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> passwordToHash;
    <span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> hashedPassword;
} passHash;

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit);
<span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span><span style="color: #0066BB;font-weight: bold">generationMotDePasse</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);

<span style="color: #888888">/* LIB_NBGENERATOR_VERSION_2_0 : Constant to be passed at compilation time */</span>
<span style="color: #888888">/* Because only one header is allowed in case of same function signature */</span>
<span style="color: #557799">#ifdef LIB_NBGENERATOR_VERSION_2_0</span>
<span style="color: #008800;font-weight: bold">struct</span> PasswordHash <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);
<span style="color: #557799">#else</span>
<span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> <span style="color: #0066BB;font-weight: bold">getRandomPassword</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters);
<span style="color: #557799">#endif</span>
</pre>
</div>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/third_client/nbgenerator.c">nbgenerator.c :</a> impl&eacute;mentation de la biblioth&egrave;que &laquo;&nbsp;<strong>libnbgenerator.so.2.0.0</strong>&nbsp;&raquo; :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">char</span> password[MAX_PASSWORD_LENGTH] <span style="color: #333333">=</span> {<span style="color: #0000DD;font-weight: bold">0</span>};

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">getPseudoNumber</span>(<span style="color: #333399;font-weight: bold">int</span> numLimit){
    <span style="color: #333399;font-weight: bold">int</span> rNumber <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    srand(time(<span style="color: #007020">NULL</span>));
    <span style="color: #008800;font-weight: bold">if</span>(numLimit <span style="color: #333333">&gt;</span> <span style="color: #0000DD;font-weight: bold">0</span>)
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> numLimit;
    <span style="color: #008800;font-weight: bold">else</span>
        rNumber <span style="color: #333333">=</span> rand() <span style="color: #333333">%</span> DEFAULT_MAX_NUMBER_LIMIT;
    <span style="color: #008800;font-weight: bold">return</span> rNumber;
}

<span style="color: #888888">// generationMotDePasse : not exported to client binary</span>
<span style="color: #333399;font-weight: bold">char</span> <span style="color: #333333">*</span><span style="color: #0066BB;font-weight: bold">generationMotDePasse</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters){
    <span style="color: #333399;font-weight: bold">short</span> i <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>;
    memset(password, <span style="color: #0000DD;font-weight: bold">0</span>, MAX_PASSWORD_LENGTH);
    
    srand(time(<span style="color: #007020">NULL</span>));
    
    <span style="color: #008800;font-weight: bold">if</span>((nbCharacters <span style="color: #333333">&gt;</span> MAX_PASSWORD_LENGTH) <span style="color: #333333">||</span> (nbCharacters <span style="color: #333333">&lt;=</span> <span style="color: #0000DD;font-weight: bold">0</span>))
        nbCharacters <span style="color: #333333">=</span> MAX_PASSWORD_LENGTH;
    <span style="color: #888888">/* G&eacute;n&eacute;ration du mot de passe */</span>
    <span style="color: #008800;font-weight: bold">for</span>(i <span style="color: #333333">=</span> <span style="color: #0000DD;font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span> nbCharacters; i<span style="color: #333333">++</span>){
        password[i] <span style="color: #333333">=</span> <span style="color: #0044DD">'A'</span> <span style="color: #333333">+</span> (rand() <span style="color: #333333">%</span> nbCharacters);
    }
    <span style="color: #008800;font-weight: bold">return</span> password;
}

<span style="color: #888888">/* @ means use this for legacy (old binaries) */</span>
__asm__(<span style="background-color: #fff0f0">".symver getRandomPassword_1_1,getRandomPassword@NBGENERATOR_1.1"</span>);
<span style="color: #333399;font-weight: bold">char</span><span style="color: #333333">*</span> <span style="color: #0066BB;font-weight: bold">getRandomPassword_1_1</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters){
    <span style="color: #008800;font-weight: bold">return</span> generationMotDePasse(nbCharacters);
}

<span style="color: #888888">/* @@ means default use this for new binaries */</span>
__asm__(<span style="background-color: #fff0f0">".symver getRandomPassword_2_0,getRandomPassword@@NBGENERATOR_2.0"</span>);
<span style="color: #008800;font-weight: bold">struct</span> PasswordHash <span style="color: #0066BB;font-weight: bold">getRandomPassword_2_0</span>(<span style="color: #333399;font-weight: bold">int</span> nbCharacters){
    <span style="color: #333399;font-weight: bold">char</span> passwordToHash[MAX_PASSWORD_LENGTH];
    <span style="color: #333399;font-weight: bold">char</span> passwordSalt[<span style="color: #0000DD;font-weight: bold">6</span>];
    
    strcpy(passwordToHash, generationMotDePasse(<span style="color: #0000DD;font-weight: bold">10</span>));
    
    <span style="color: #888888">// $1$ allows to select md5 hashing algorithm    </span>
    sprintf(passwordSalt, <span style="background-color: #fff0f0">"$6$%s"</span>, generationMotDePasse(<span style="color: #0000DD;font-weight: bold">6</span>));

    sprintf(passHash.hashNameFunc, <span style="background-color: #fff0f0">"%s"</span>, ENCRYPTION_CIPHER_METHOD);
    
    <span style="color: #888888">/* Crypt returns a hash based on DES encryption */</span>
    passHash.hashedPassword <span style="color: #333333">=</span> crypt(passwordToHash, passwordSalt);

    <span style="color: #008800;font-weight: bold">return</span> passHash;
}
</pre>
</div>
<p>Le code n&eacute;cessite quelques petites remarques :</p>
<ul>
<li>Les deux fonctions getRandomPassword doivent &ecirc;tre d&eacute;clar&eacute;es avec des noms diff&eacute;rents (<em>par exemple </em><strong><em>getRandomPassword_1_1</em></strong><em>() pour la fonction </em><strong><em>getRandomPassword()</em></strong><em> associ&eacute;e au symbole </em><strong><em>NBGENERATOR_1.1</em></strong>). La directive symver est employ&eacute;e pour faire le mapping.</li>
<li> Le symbole @ se traduit par : appliquer cette r&eacute;gle &agrave; tout ancien binaire contrairement au @@ qui force le linker &agrave; utiliser cette fonction avec tous les nouveaux binaires qui seront compil&eacute;s ult&eacute;rieurement.</li>
</ul>
<p><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/third_client/script_version">script_version :</a> Il nous faut juste ins&eacute;rer le tag NBGENERATOR_2.0 dans le linker script :</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%">NBGENERATOR_1.0<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getPseudoNumber;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;

NBGENERATOR_1.1<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getRandomPassword;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;

NBGENERATOR_2.0<span style="color: #333333">{</span>
    <span style="color: #007020">global</span>:
        getRandomPassword;
    <span style="color: #007020">local</span>:
        *;
<span style="color: #333333">}</span>;
</pre>
</div>
<p>Et enfin, la derni&egrave;re pi&egrave;ce de puzzle qui permet de tester notre biblioth&egrave;que, le troisi&egrave;me client :</p>
<p><strong><a href="https://github.com/jugurthab/linux_embedded_articles/blob/master/library-versioning/symbol_versioning_method/third_client/troisiemeClient.c">troisiemeClient.c :</a></strong> troisi&egrave;me binaire client.</p>
<div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em">
<pre style="margin: 0;line-height: 125%"><span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include "nbgenerator.h"</span>

<span style="color: #333399;font-weight: bold">int</span> <span style="color: #0066BB;font-weight: bold">main</span>(){
    <span style="color: #008800;font-weight: bold">struct</span> PasswordHash pass <span style="color: #333333">=</span> getRandomPassword(<span style="color: #0000DD;font-weight: bold">10</span>);
    printf(<span style="background-color: #fff0f0">"Le nombre al&eacute;atoire est %d</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>, getPseudoNumber(<span style="color: #0000DD;font-weight: bold">1500</span>));
    printf(<span style="background-color: #fff0f0">"Le mot de passe avec hash : %s avec la fonction =&gt; %s</span><span style="color: #666666;font-weight: bold;background-color: #fff0f0">n</span><span style="background-color: #fff0f0">"</span>,
            pass.hashedPassword, pass.hashNameFunc);

    <span style="color: #008800;font-weight: bold">return</span> <span style="color: #0000DD;font-weight: bold">0</span>;
}
</pre>
</div>
<p>Il est temps d&rsquo;ex&eacute;cuter et compiler notre programme :</p>
<ul class="wp-block-gallery aligncenter columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_symver_compiling.png" alt="" data-id="7091" data-link="https://www.linuxembedded.fr/?attachment_id=7091" class="wp-image-7091 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_symver_compiling.png 787w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_symver_compiling-300x116.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/library_symver_compiling-768x296.png 768w" sizes="(max-width: 787px) 100vw, 787px"></figure>
</li>
</ul>
<p>Pour finir, voici l&rsquo;ex&eacute;cution des trois programmes qui d&eacute;pendent d&eacute;sormais de <strong>libnbgenerator.2.0.0</strong> :</p>
<ul class="wp-block-gallery columns-1 is-cropped">
<li class="blocks-gallery-item">
<figure><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/11/all_lib_compilation_works.png" alt="" data-id="7092" data-link="https://www.linuxembedded.fr/?attachment_id=7092" class="wp-image-7092 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/11/all_lib_compilation_works.png 789w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/all_lib_compilation_works-300x71.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/11/all_lib_compilation_works-768x182.png 768w" sizes="(max-width: 789px) 100vw, 789px"></figure>
</li>
</ul>
<p style="text-align:center"><strong>Important</strong><br />Il est &agrave; noter que la m&eacute;thode &laquo;&nbsp;gestion de symbole&nbsp;&raquo; peut augmenter la taille de la biblioth&egrave;que g&eacute;n&eacute;r&eacute;e (<em>comme dans notre exemple avec la pr&eacute;sence des deux fonctions getRandomPassword()</em>), c&rsquo;est l&rsquo;une des raisons qui rend la glibc volumineuse. Cet inconv&eacute;nient est souvent n&eacute;glig&eacute; par rapport &agrave; ses nombreux avantages. </p>
<h2>Conclusion</h2>
<p>Dans cet article, nous avons d&eacute;couvert un concept avanc&eacute; de la gestion des biblioth&egrave;ques partag&eacute;es. Il est primordial de concevoir ses biblioth&egrave;ques avec l&rsquo;une de ces deux m&eacute;thodes : le lien type &laquo;&nbsp;soname&nbsp;&raquo; ou la gestion des symboles (<em>cette derni&egrave;re est &agrave; pr&eacute;coniser</em>).<br />Ces m&eacute;thodes permettent de maintenir et faire &eacute;voluer les biblioth&egrave;ques, d&rsquo;am&eacute;liorer le code et d&rsquo;apporter des corrections aux failles de s&eacute;curit&eacute; sans avoir &agrave; recompiler le binaire du client final (<em>c&rsquo;est la retro-compatibilit&eacute;</em>).</p>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>FlameGraph</title>
		<link>https://dev-pro.xyz/blog/flamegraph/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:34 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[debug]]></category>
		<category><![CDATA[kernel]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[perf]]></category>
		<category><![CDATA[Technologie]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/flamegraph/</guid>
				<description><![CDATA[Introduction Les outils de profilage permettent lors de l&#8217;ex&#233;cution d&#8217;un logiciel de contr&#244;ler la liste des fonctions appel&#233;es, le temps pass&#233; dans chacune d&#8217;elle, l&#8217;utilisation des ressources processeur ou l&#8217;utilisation m&#233;moire par exemple. Sous Linux une multitude d&#8217;outils sont disponibles et si vous avez d&#233;j&#224; utilis&#233; Perf ou eBPF vous avez sans nul doute remarqu&#233; ... <a href="https://dev-pro.xyz/blog/flamegraph/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<h1>Introduction</h1>
<p> Les outils de profilage permettent lors de l&rsquo;ex&eacute;cution d&rsquo;un logiciel de contr&ocirc;ler la liste des <a href="https://fr.wikipedia.org/wiki/Fonction_informatique">fonctions</a> appel&eacute;es, le temps pass&eacute; dans chacune d&rsquo;elle, l&rsquo;utilisation des ressources <a href="https://fr.wikipedia.org/wiki/Processeur">processeur</a> ou l&rsquo;utilisation <a href="https://fr.wikipedia.org/wiki/M%C3%A9moire_(informatique)">m&eacute;moire</a> par exemple. Sous Linux une multitude d&rsquo;outils sont disponibles et si vous avez d&eacute;j&agrave; utilis&eacute; Perf ou eBPF vous avez sans nul doute remarqu&eacute; que la quantit&eacute; de log g&eacute;n&eacute;r&eacute;e peut rapidement devenir gargantuesque et donc difficilement interpr&eacute;table.</p>
<p>Cet article va vous pr&eacute;senter les FlameGraph : un outil tr&egrave;s pratique de visualisation des logs d&rsquo;applications profil&eacute;es qui a &eacute;t&eacute; d&eacute;velopp&eacute; par Brendan Gregg, ing&eacute;nieur chez Netflix et sp&eacute;cialiste de l&rsquo;analyse de performance. Les FlameGraph sont une une repr&eacute;sentation des logs de n&rsquo;importe quel outil de g&eacute;n&eacute;ration de donn&eacute;es de profiling comme eBPF et Perf qui sont &eacute;galement des traceurs d&eacute;j&agrave; introduits par les excellents articles de Jugurtha :</p>
<ul>
<li><a href="http://www.linuxembedded.fr/2018/12/les-traceurs-sous-linux-1/">http://www.linuxembedded.fr/2018/12/les-traceurs-sous-linux-1/</a>&nbsp;: introduction au tra&ccedil;age et profilage d&rsquo;applications ainsi que le principe de fonctionnement de Ftrace et ses outils front-end.</li>
<li><a href="http://www.linuxembedded.fr/2019/02/les-traceurs-sous-linux-2/">http://www.linuxembedded.fr/2019/02/les-traceurs-sous-linux-2/</a>&nbsp;: utilisation de perf, avec des exemples de commandes utiles que je vais utiliser dans cet article.</li>
<li><a href="http://www.linuxembedded.fr/2019/03/les-secrets-du-traceur-ebpf/">http://www.linuxembedded.fr/2019/03/les-secrets-du-traceur-ebpf/</a></li>
</ul>
<p>Cet article n&rsquo;est qu&rsquo;un exemple d&rsquo;utilisation des FlameGraph pr&eacute;c&eacute;d&eacute; de quelques notions. Tout le m&eacute;rite revient &eacute;videmment &agrave; Brendan Gregg. Vous pouvez retrouver son blog qui sert de r&eacute;f&eacute;rence aux m&eacute;thodes de profilage, au lien suivant : <a href="http://www.brendangregg.com/overview.html">http://www.brendangregg.com/overview.html</a></p>
<h2>G&eacute;n&eacute;ration d&rsquo;un FlameGraph on-CPU</h2>
<p>Une des mani&egrave;res de profiler une application revient &agrave; d&eacute;terminer pourquoi le CPU est occup&eacute;. Une fa&ccedil;on efficace de faire cela est le profilage par &eacute;chantillonnage&nbsp;: on envoie &agrave; une certaine fr&eacute;quence une interruption au CPU pour r&eacute;cup&eacute;rer la stack trace, l&rsquo;adresse en m&eacute;moire de l&rsquo;instruction en cours d&rsquo;ex&eacute;cution (Program Counter) ainsi que l&rsquo;adresse de la fonction. Nous allons dans notre exemple utiliser la commande Perf pour ce faire.</p>
<p>Vous pouvez installer Perf sur votre distribution via votre gestionnaire de paquet&nbsp;: linux-perf sous debian, perf sous CentOS et Arch, linux-tools sous Ubuntu&hellip; De plus si vous voulez qu&rsquo;un utilisateur non root puisse collecter des donn&eacute;es dans votre terminal courant, il est possible de modifier la valeur de la variable perf_event_paranoid&nbsp;:</p>
<pre class="wp-block-preformatted"> <strong>echo -1 &gt; /proc/sys/kernel/perf_event_paranoid</strong>.</pre>
<p>NB : les programmes que vous profilez doivent comporter des symboles de debug n&eacute;cessaires &agrave; la traduction des adresses m&eacute;moire en nom de fonction.</p>
<p>Si vous voulez profiler une application int&eacute;gr&eacute;e dans votre distribution via Yocto il faut installer la version  &laquo;&nbsp;-dbg&nbsp;&raquo; du paquet que vous souhaitez analyser. Vous pouvez &eacute;galement utiliser l&rsquo;image feature &laquo;&nbsp;dbg-pkgs&nbsp;&raquo; pour cr&eacute;er une version de votre image int&eacute;grant tous les paquets de debug ce qui peut &ecirc;tre utile pour profiler le syst&egrave;me complet.</p>
<p>Sur Debian pour installer des paquets avec les symboles de debug il faut ajouter la source <strong>deb</strong> <strong>http://debug.mirrors.debian.org/debian-debug/ buster-debug main</strong> (pour debian buster) dans votre source.list d&rsquo;apt. Apr&egrave;s &ccedil;a vous pouvez installer les paquets de debug qui ont en g&eacute;n&eacute;ral comme suffixe -dbgsym.</p>
<p>Une autre source potentielle de probl&egrave;me peut &ecirc;tre que la stack trace retourn&eacute;e est incompl&egrave;te pour les applications qui sont compil&eacute;es avec des optimisations de compilation. Dans ce cas il faut recompiler l&rsquo;application avec l&rsquo;option <strong>&ndash;</strong><strong>fno-omit-frame-pointer.</strong></p>
<p>De la m&ecirc;me mani&egrave;re il est possible que la stack trace du kernel soit incompl&egrave;te si l&rsquo;option CONFIG_FRAME_POINTER est d&eacute;sactiv&eacute;e (Kernel hacking/Compile-time-checks and compiler option)</p>
<p>La proc&eacute;dure pour g&eacute;n&eacute;rer les FlameGraph CPU est tr&egrave;s simple, il suffit dans un premier temps de lancer la commande suivante pour profiler pendant 30 secondes et &agrave; une fr&eacute;quence de 99Hz (99 interruptions par seconde) une application qui a un PID valant 12345 par exemple&nbsp;:</p>
<pre class="wp-block-preformatted"><strong>perf record -F 99 -p 12345 -g -- sleep 30</strong></pre>
<p>On peut &eacute;galement profiler le syst&egrave;me complet et donc tous les coeurs de la CPU avec l&rsquo;option -a&nbsp;:</p>
<pre class="wp-block-preformatted"><strong>perf record -F 99 -a -g -- sleep 30</strong></pre>
<p>Cela va g&eacute;n&eacute;rer un fichier perf.data qui contient les &eacute;chantillons qui peuvent &ecirc;tre lus via la commande perf report :</p>
<pre class="wp-block-preformatted"><strong>perf report -n --stdio</strong> </pre>
<p>Perf est un outil tr&egrave;s puissant mais en lan&ccedil;ant les 2 derni&egrave;res commandes sur ma machine, le rapport g&eacute;n&eacute;r&eacute; fait plus d&rsquo;un millier de lignes. Et c&rsquo;est bien l&agrave; l&rsquo;int&eacute;r&ecirc;t des FlameGraph. Ils sont tr&egrave;s facile &agrave; g&eacute;n&eacute;rer et tr&egrave;s faciles &agrave; interpr&eacute;ter rapidement.</p>
<p>Dans mon cas j&rsquo;ai g&eacute;n&eacute;r&eacute; mes Flame Graphs sur une cible dont la distribution a &eacute;t&eacute; g&eacute;n&eacute;r&eacute;e via Yocto ; voici une recette tr&egrave;s simple qui va r&eacute;cup&eacute;rer les sources du projet et les installer dans la cible&nbsp;: </p>
<pre class="wp-block-preformatted">SUMMARY = "Flamegrah Yocto recipe"
DESCRIPTION = "Flamegraph are a visualization tool for profiled application logs"
LICENSE = "CLOSED"

S = "${WORKDIR}/git"

SRC_URI = "git://github.com/brendangregg/FlameGraph.git;protocol=https"
SRCREV = "1b1c6deede9c33c5134c920bdb7a44cc5528e9a7"

RDEPENDS_flamegraph = "perl"

FILES_${PN} += "flamegraph/"
do_install() {
     install -d  ${D}/flamegraph
     install -m  0755 ${S}/*.pl ${D}/flamegraph
}</pre>
<p>Vu que rien n&rsquo;est compil&eacute; dans le projet vous pouvez &eacute;galement cloner le projet &agrave; l&rsquo;URI suivant et le copier sur la cible&nbsp;: </p>
<pre class="wp-block-preformatted"><strong>git clone https://github.com/brendangregg/FlameGraph</strong></pre>
<p>Le projet consiste en une multitude de scripts perl ainsi que des exemples de FlameGraph d&eacute;j&agrave; g&eacute;n&eacute;r&eacute;s et pr&eacute;sent&eacute;s sur le blog de Brendan Gregg. A partir d&rsquo;un fichier perf.data g&eacute;n&eacute;r&eacute; par <em>perf</em> on peut le copier dans le r&eacute;pertoire du projet et lancer la commande suivante pour g&eacute;n&eacute;rer un flamegraph :</p>
<pre class="wp-block-preformatted"><strong>perf script | ./stackcollapse-perf.pl &gt; out.perf-folded &amp;&amp; ./flamegraph.pl out.perf-folded &gt; flamegraph.svg</strong> </pre>
<ul>
<li>perf script va chercher dans le r&eacute;pertoire local un fichier perf.data (g&eacute;n&eacute;r&eacute; par perf record) et afficher la trace. Attention n&eacute;anmoins cette commande est d&eacute;pendante de l&rsquo;architecture de la plateforme. Il faut donc g&eacute;n&eacute;rer les Flamegraph directement sur la cible.</li>
<li>stackcollapse-perf va formater la trace en une seule ligne pour qu&rsquo;elle puisse &ecirc;tre trait&eacute;e par le script flamegraph.pl</li>
<li>flamegraph.pl transforme le fichier out.perf-folded en une image de flamegraph.</li>
</ul>
<p>On g&eacute;n&egrave;re donc un fichier SVG qui peut facilement &ecirc;tre ouvert depuis un navigateur. Je vais vous pr&eacute;senter ici un exemple tr&egrave;s simple de FlameGraph issu d&rsquo;un petit programme.</p>
<p>D&rsquo;une part le programme va dans un premier thread ouvrir un fichier, &eacute;crire dedans, le refermer en boucle et va dans un autre thread lancer une boucle vide qui va faire mouliner le processeur. Si on profile le syst&egrave;me entier pendant 60 secondes et qu&rsquo;on lance pendant cette p&eacute;riode le programme pendant 30 secondes on obtient le r&eacute;sultat suivant&nbsp;:</p>
<figure class="wp-block-image is-resized"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-1024x633.png" alt="" class="wp-image-6947 img-fluid" width="827" height="511" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-1024x633.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-300x186.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_-768x475.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/flamegraph.svg_.png 1250w" sizes="(max-width: 827px) 100vw, 827px"></figure>
<p>Interpr&eacute;tation du r&eacute;sultat&nbsp;:</p>
<ul>
<li>Chaque boite repr&eacute;sente l&rsquo;appel &agrave; une fonction dans la pile</li>
<li>L&rsquo;axe des ordonn&eacute;es pr&eacute;sente la profondeur de la pile</li>
<li>La largeur des frame en abscisse correspond au temps pass&eacute; (nombre d&rsquo;&eacute;chantillons) par un CPU &agrave; ex&eacute;cuter la fonction correspondante.</li>
</ul>
<p>Dans notre cas il est tr&egrave;s facile de d&eacute;celer les t&acirc;ches gourmandes en CPU. Pour interpr&eacute;ter un Flame Graph on va chercher les boites larges tout en haut de la pile et voir par quelles fonctions elles ont &eacute;t&eacute; appel&eacute;es. Ici on remarque que la case &laquo;&nbsp;cpu_moulineur&nbsp;&raquo; est extr&ecirc;mement large, c&rsquo;est elle qui correspond &agrave; la fonction contenant une boucle vide.</p>
<p>Si on positionne le curseur de la souris sur la boite &laquo;&nbsp;cpu_moulineur&nbsp;&raquo;&nbsp;un champ affiche le nombre d&rsquo;&eacute;chantillons (et donc le temps pass&eacute; dans la fonction) ainsi que le pourcentage correspondant par rapport &agrave; la mesure compl&egrave;te.</p>
<p>Le bloc situ&eacute; &agrave; sa droite correspond &agrave; la fonction qui ouvre et ferme un fichier en boucle. En plus d&rsquo;observer le nombre d&rsquo;&eacute;chantillons pour chaque boite, il est int&eacute;ressant de voir l&rsquo;encha&icirc;nement des fonctions appel&eacute;es de l&rsquo;userspace jusqu&rsquo;aux strates les plus enfouies du kernel.</p>
<p>Ici l&rsquo;exemple est relativement trivial mais dans un plus gros projet cela peut s&rsquo;av&eacute;rer tr&egrave;s utile car les FlameGraph offrent une vision globale des fonctions appel&eacute;es par une application&nbsp;! On peut voir par exemple si l&rsquo;appel &agrave; une fonction userspace provoque l&rsquo;appel &agrave; un kmalloc c&ocirc;t&eacute; kernel.</p>
<p>NB&nbsp;: on ne sait n&eacute;anmoins pas &agrave; quel moment les fonctions sont appel&eacute;es car il n&rsquo;y a pas de notion temporelle dans les flamegraph CPU.</p>
<h1>D&rsquo;autres types de FlameGraph int&eacute;ressants</h1>
<h2>FlameGraph off-CPU</h2>
<p>Les FlameGraph on-CPU permettent de comprendre l&rsquo;usage CPU mais ne permettent pas de voir les probl&egrave;mes de latence pr&eacute;sents quand un thread est en attente d&rsquo;une I/O bloqu&eacute;e, d&rsquo;un timer ou quand il y a un changement de contexte. Cela constitue une forme d&rsquo;analyse &agrave; part enti&egrave;re que Brendan Gregg appelle analyse off-CPU (en opposition &agrave; on-CPU).</p>
<p>En r&eacute;sum&eacute; l&rsquo;analyse off-CPU est un moyen de localiser de la latence introduite par le blocage de thread, cette analyse est compl&eacute;mentaire &agrave; l&rsquo;analyse on-CPU et est n&eacute;cessaire &agrave; la compr&eacute;hension du cycle de vie d&rsquo;un thread.</p>
<p>Leur g&eacute;n&eacute;ration peut &ecirc;tre r&eacute;alis&eacute;e via le script offcputime de bcc (je vous renvoie vers l&rsquo;article de Jugurtha) qui permet de trouver pourquoi et pendant combien de temps un thread est bloqu&eacute; et ce quelque soit le type de blocage.</p>
<p>Une approche est de tracer les appels aux fonctions malloc et free et afficher sur un Flame Graph le nombre de fois o&ugrave; les fonctions ont a &eacute;t&eacute; appel&eacute;es ou le nombre de bytes qui ont &eacute;t&eacute; allou&eacute;s pour chaque frame.</p>
<h1>Conclusion</h1>
<p>En r&eacute;sum&eacute; le Flame Graph est un puissant outil de visualisation de logs d&rsquo;outils d&rsquo;analyse de performance qui peut vous permettre de gagner un temps pr&eacute;cieux. J&rsquo;ai simplement voulu vous partager cette d&eacute;couverte dans cet article qui n&rsquo;est qu&rsquo;une rapide pr&eacute;sentation, je vous invite une nouvelle fois &agrave; vous rendre sur le blog de Brendan Gregg pour beaucoup plus de d&eacute;tails !</p>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Le Temps Reel sous Linux</title>
		<link>https://dev-pro.xyz/blog/le-temps-reel-sous-linux/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:33 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[kernel]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[preempt-rt]]></category>
		<category><![CDATA[Technologie]]></category>
		<category><![CDATA[temps réel]]></category>
		<category><![CDATA[WhitePaper]]></category>
		<category><![CDATA[Xenomai]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/le-temps-reel-sous-linux/</guid>
				<description><![CDATA[Dans cet article, nous allons discuter de l&#8217;int&#233;r&#234;t ainsi que des avantages et inconv&#233;nients d&#8217;utiliser un noyau Linux temps r&#233;el. L&#8217;objectif de cet article n&#8217;est pas de d&#233;crire ce qu&#8217;est le temps r&#233;el mais pourquoi et comment l&#8217;utiliser.&#160;Aux lecteurs curieux et int&#233;ress&#233;s par le temps r&#233;el, je recommande le livre de Christophe Blaess, Solutions temps ... <a href="https://dev-pro.xyz/blog/le-temps-reel-sous-linux/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<p>Dans cet article, nous allons discuter de l&rsquo;int&eacute;r&ecirc;t ainsi que des avantages et inconv&eacute;nients d&rsquo;utiliser un noyau Linux temps r&eacute;el. L&rsquo;objectif de cet article n&rsquo;est pas de d&eacute;crire ce qu&rsquo;est le temps r&eacute;el mais pourquoi et comment l&rsquo;utiliser.&nbsp;<br />Aux lecteurs curieux et int&eacute;ress&eacute;s par le temps r&eacute;el, je recommande le livre de<strong><em> </em></strong>Christophe Blaess, <em>Solutions temps r&eacute;el sous Linux</em>.</p>
<h1>Introduction</h1>
<h3>Historique</h3>
<p>La notion de temps r&eacute;el a commenc&eacute; &agrave; appara&icirc;tre dans les ann&eacute;es 60 dans le domaine de l&rsquo;a&eacute;rospatial. En effet, l&rsquo;un des premiers syst&egrave;mes embarqu&eacute;s temps r&eacute;el fut l&rsquo;Apollo Guidance Computer con&ccedil;u par le MIT permettant du traitement temps r&eacute;el des donn&eacute;es recueillies lors du vol. La notion de temps r&eacute;el a cependant bien &eacute;volu&eacute; jusqu&rsquo;&agrave; maintenant.</p>
<p>De nos jours, de nombreux syst&egrave;mes requi&egrave;rent des performances dites temps r&eacute;el. En effet, le march&eacute; des syst&egrave;mes embarqu&eacute;s est en pleine croissance et le besoin de solutions embarqu&eacute;es temps r&eacute;el augmente en cons&eacute;quence. Le temps r&eacute;el se retrouve en particulier dans les domaines suivants : </p>
<ul>
<li>Automobile</li>
<li>Automatique industrielle&nbsp;</li>
<li>T&eacute;l&eacute;communications</li>
<li>Sant&eacute;/M&eacute;dical</li>
<li>A&eacute;ronautique/A&eacute;rospatial</li>
</ul>
<h3>Qu&rsquo;est ce que le temps r&eacute;el ?</h3>
<p>&nbsp;&nbsp;&nbsp; Il ne faut pas confondre temps r&eacute;el avec vitesse. Par exemple le syst&egrave;me de commande d&rsquo;un avion n&eacute;cessitera un temps de r&eacute;ponse de l&rsquo;ordre de la microseconde alors le syst&egrave;me de contr&ocirc;le d&rsquo;une cha&icirc;ne de production n&eacute;cessitera un temps de r&eacute;ponse de l&rsquo;ordre de la milliseconde. En revanche, il devront tous deux r&eacute;pondre dans un laps de temps d&eacute;fini et ne pas le d&eacute;passer. </p>
<p>Il existe plusieurs notions de temps r&eacute;el : <strong>Le temps r&eacute;el strict (hard real time) et le temps r&eacute;el souple (soft real time).&nbsp;</strong></p>
<p>&nbsp;&nbsp;&nbsp; Le temps r&eacute;el strict p&eacute;nalise le non-respect d&rsquo;une &eacute;ch&eacute;ance par l&rsquo;&eacute;mission d&rsquo;une erreur. La r&eacute;ponse du syst&egrave;me est donc consid&eacute;r&eacute;e comme erron&eacute;e. En revanche un temps r&eacute;el souple tol&egrave;re une certaine marge de d&eacute;passement.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png" alt="" class="wp-image-6902 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png 625w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple-300x64.png 300w" sizes="(max-width: 625px) 100vw, 625px"><figcaption>Image 1 : Diff&eacute;rence soft (droite) et hard (gauche) real time</figcaption></figure>
</div>
<h3>Les solutions temps r&eacute;el</h3>
<p>&nbsp;&nbsp;&nbsp; Plusieurs solutions temps r&eacute;el sont disponibles aujourd&rsquo;hui, propri&eacute;taires comme libres. En voici quelques exemples : </p>
<ul>
<li>FreeRTOS</li>
<li>QNX</li>
<li>VxWorks</li>
</ul>
<hr class="wp-block-separator">
<p>On peut ensuite lister les solutions avec noyaux hybrides qui pr&eacute;sentent d&rsquo;autres avantages. Certaines de ces solutions permettent d&rsquo;utiliser un noyau Linux et d&rsquo;y installer &agrave; c&ocirc;t&eacute; un noyau temps r&eacute;el. On peut citer : </p>
<ul>
<li>Xenomai (Cobalt), Xenomai Mercury est simplement l&rsquo;utilisation de l&rsquo;API Xenomai sur un noyau Linux patch&eacute; PREEMPT_RT.</li>
<li>RTAI</li>
</ul>
<p>Xenomai se distingue par ses performances ainsi que la possibilit&eacute; d&rsquo;utiliser son API sans avoir obligatoirement &agrave; utiliser son co-noyau Xenomai Cobalt. A cet effet, Xenomai se d&eacute;cline en deux versions : Cobalt (co-noyau) et Mercury.</p>
<p>Cobalt est la version la plus int&eacute;ressante si l&rsquo;on veut faire du temps r&eacute;el strict. Cobalt utilise le patch I-pipe qui installe un pipeline redistribuant les interruptions entre le noyau linux (pour les interruptions non temps r&eacute;el) et le noyau Cobalt (pour les interruptions temps r&eacute;el). Attention cependant, il est important de regarder la compatibilit&eacute; du patch avec le mat&eacute;riel utilis&eacute;.</p>
<p>Mercury lui, permet d&rsquo;utiliser l&rsquo;API Xenomai sur un noyau linux patch&eacute; PREEMPT_RT. Mercury est plus simple &agrave; impl&eacute;menter que Cobalt mais reste moins performant.</p>
<hr class="wp-block-separator">
<p>&nbsp;&nbsp;&nbsp; Le noyau Linux mainline quant &agrave; lui poss&egrave;de quelques briques de base n&eacute;cessaire au temps r&eacute;el, comme par exemple un scheduler qui propose des politiques de scheduling temps r&eacute;el. </p>
<p>En effet, dans les options de kernel, on peut choisir la pr&eacute;emptibilit&eacute; du noyau linux. Par d&eacute;faut, seulement 3 options sont disponibles, la meilleure de ces trois options pour s&rsquo;approcher d&rsquo;un comportement temps r&eacute;el &eacute;tant la pr&eacute;emptibilit&eacute; Low-Latency. Cependant si l&rsquo;on veut vraiment faire du temps r&eacute;el, il faudra se tourner vers d&rsquo;autres solutions. </p>
<p>Il est possible d&rsquo;ajouter deux autres options de configuration en patchant le kernel &agrave; l&rsquo;aide du patch PREEMPT_RT. Ce patch n&rsquo;est actuellement pas pris en charge par le kernel mainline mais est en bonne voie pour devenir partie int&eacute;grante du kernel dans les mois ou les ann&eacute;es &agrave; venir.</p>
<figure class="wp-block-image"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png" alt="" class="wp-image-6938 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-300x171.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-768x437.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt.png 1040w" sizes="(max-width: 1024px) 100vw, 1024px"></figure>
<p>&nbsp;&nbsp;&nbsp; Nous allons maintenant parcourir les changements introduits par le patch PREEMPT_RT, &eacute;valuer les performances des diff&eacute;rentes solutions temps r&eacute;el sous Linux et &eacute;voquer des exemples d&rsquo;impl&eacute;mentation de temps r&eacute;el sous linux.</p>
<hr class="wp-block-separator">
<h1>Apports du patch PREEMPT_RT</h1>
<p>&nbsp;&nbsp;&nbsp; Le patch PREEMPT_RT ajoute l&rsquo;option de compilation du noyau CONFIG_PREEMPT_RT_FULL. Elle se traduit par l&rsquo;ajout de lignes dans le code du kernel, de type : </p>
<pre class="wp-block-code"><code>#ifdef CONFIG_PREEMPT_RT_FULL
&lt;code modifi&eacute; RT&gt;
#else
&lt;code vanilla&gt;
#endif</code></pre>
<p>&nbsp;&nbsp;&nbsp; Le principe du patch PREEMPT RT est d&rsquo;autoriser la pr&eacute;emption partout m&ecirc;me dans les interruptions, &agrave; l&rsquo;aide de l&rsquo;ajout des m&eacute;canismes  que nous allons d&eacute;crire ci-apr&egrave;s.</p>
<h3>Spinlock et Mutex</h3>
<p>&nbsp;&nbsp;&nbsp; Dans le patch PREEMPT_RT, l&rsquo;int&eacute;r&ecirc;t est de pouvoir pr&eacute;empter toutes les t&acirc;ches, m&ecirc;mes celles poss&eacute;dant un spinlock, pour laisser s&rsquo;ex&eacute;cuter la t&acirc;che la plus prioritaire. Dans cette optique, le r&ocirc;le du patch est donc de transformer les spinlocks actuels en sleeping spinlocks, soit en rt_mutex. En effet, les spinlocks ne sont pas pr&eacute;emptibles par d&eacute;faut, ce qui peut poser probl&egrave;me lorsqu&rsquo;on fait du temps r&eacute;el.</p>
<p>On peut le voir dans le fichier <em>&lt;spinlock_types.h&gt;</em> : </p>
<pre class="wp-block-code"><code>#include &lt;linux/spinlock_types_raw.h&gt;

#ifndef CONFIG_PREEMPT_RT_FULL
# include &lt;linux/spinlock_types_nort.h&gt;
# include &lt;linux/rwlock_types.h&gt;
#else
# include &lt;linux/rtmutex.h&gt;
# include &lt;linux/spinlock_types_rt.h&gt;
# include &lt;linux/rwlock_types_rt.h&gt;
#endif</code></pre>
<p>Et dans le fichier <em>&lt;linux/spinlock_types_rt.h&gt;</em> :</p>
<pre class="wp-block-code"><code>typedef struct spinlock {
    struct rt_mutex        lock;
    unsigned int        break_lock;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
    struct lockdep_map    dep_map;
#endif
} spinlock_t;</code></pre>
<p>&nbsp;&nbsp;&nbsp; Voici ci-dessous le fonctionnement des spinlocks dans un kernel mainline. Prenons l&rsquo;exemple d&rsquo;un programme poss&eacute;dant deux threads, tout deux s&rsquo;ex&eacute;cutant sur un m&ecirc;me coeur. Le premier thread (VERT), se lance jusqu&rsquo;&agrave; rencontrer une zone de code prot&eacute;g&eacute;e par un spinlock. Pendant ce temps, le thread 2 (BLEU), plus prioritaire est pr&ecirc;t &agrave; s&rsquo;ex&eacute;cuter mais comme le thread 1 est dans un spinlock, le thread 2 devra attendre la fin de la zone de code prot&eacute;g&eacute;e par un spinlock.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png" alt="" class="wp-image-6839 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png 792w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-300x92.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-768x237.png 768w" sizes="(max-width: 792px) 100vw, 792px"><figcaption>Image 2 : Exemple spinlocks avant patch preempt RT</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Maintenant avec le patch PREEMPT_RT, on voit que le scheduler donne la main au thread 2 poss&eacute;dant une priorit&eacute; plus &eacute;lev&eacute;e. Ces changements peuvent &ecirc;tre lus sur la documentation de la fondation Linux, on peut voir notamment qu&rsquo;un spinlock se comporte donc comme un rt_mutex (&ldquo;<em>In order to minimize the changes to the kernel source the existing spinlock_t datatype and the functions which operate on it retain their old names but, when PREEMPT_RT is enabled, now refer to an rt_mutex lock</em>&rdquo;) : </p>
<p><a href="https://wiki.linuxfoundation.org/realtime/documentation/technical_details/sleeping_spinlocks">https://wiki.linuxfoundation.org/realtime/documentation/technical_details/sleeping_spinlocks</a></p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png" alt="" class="wp-image-6841 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png 846w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-300x93.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-768x237.png 768w" sizes="(max-width: 846px) 100vw, 846px"><figcaption>Image 3 : Image 2 : Exemple spinlocks apr&egrave;s patch preempt RT</figcaption></figure>
</div>
<h3>Raw spinlock</h3>
<p>&nbsp;&nbsp;&nbsp; Bien que les spinlocks deviennent des mutex, il reste des endroits dans le kernel o&ugrave; il est n&eacute;cessaire d&rsquo;avoir recours &agrave; de vrais spinlocks. En effet, certains endroits du kernel ne devraient pas &ecirc;tre pr&eacute;emptibles car ils sont vraiment critiques. </p>
<p>De plus, les spinlocks ont l&rsquo;avantage d&rsquo;&ecirc;tre plus rapides que les mutex. Pour cela, il existe les raw_spinlocks qui sont en r&eacute;alit&eacute; les spinlocks du kernel classique non patch&eacute;. </p>
<p>Ils ont &eacute;t&eacute; ajout&eacute;s au kernel mainline mais ne sont d&rsquo;aucune utilit&eacute; dans un kernel non patch&eacute;. Il faut cependant prendre garde &agrave; leur utilisation dans un syst&egrave;me temps r&eacute;el. En effet, les raw_spinlocks d&eacute;sactivent la pr&eacute;emption et les interruptions, ce qui peut engendrer des latences non d&eacute;sir&eacute;es et donc d&eacute;grader l&rsquo;aspect temps r&eacute;el du syst&egrave;me. </p>
<h3>Threaded Interrupts</h3>
<p>&nbsp;&nbsp;&nbsp; Comme l&rsquo;objectif du patch PREEMPT_RT est de rendre le kernel aussi pr&eacute;emptible que possible, il para&icirc;t normal de modifier le fonctionnement des interruptions. Nous allons tout d&rsquo;abord revoir le fonctionnement classique des interruptions.</p>
<p><strong>Interruptions classiques :</strong> Dans le kernel linux, lorsque une interruption survient, c&rsquo;est &agrave; dire lorsqu&rsquo;un p&eacute;riph&eacute;rique externe change d&rsquo;&eacute;tat (des donn&eacute;es sur le port ethernet, le changement d&rsquo;&eacute;tat d&rsquo;une broche GPIO, etc.), le p&eacute;riph&eacute;rique envoie un signal au gestionnaire d&rsquo;interruptions APIC (<em>Advanced Programmable Interrupt Controler</em>). </p>
<p>Le gestionnaire transmet ensuite une requ&ecirc;te d&rsquo;interruption IRQ (Interrupt Request) au processeur. Ce dernier s&rsquo;arr&ecirc;te, sauvegarde son contexte puis traite l&rsquo;interruption concern&eacute;e. Pour traiter l&rsquo;interruption, plusieurs m&eacute;thodes existent, mais la plus courante est celle des top-half et bottom-half.</p>
<p><strong>Top-half et bottom-half interrupts handler : </strong>Pour traiter une interruption en &eacute;vitant de monopoliser une unit&eacute; de calcul, le moyen le plus utilis&eacute; est celui des <em>top-half</em> et <em>bottom-half</em>. </p>
<p>Ce m&eacute;canisme consiste &agrave; ex&eacute;cuter le top-half au moment de l&rsquo;interruption, qui effectuera le minimum vital au traitement de l&rsquo;ex&eacute;cution. Il programmera ensuite dans une file d&rsquo;ex&eacute;cution un handler <em>bottom-half</em> qui traitera l&rsquo;interruption proprement une fois qu&rsquo;elle sera d&eacute;masqu&eacute;e dans l&rsquo;APIC et que le processeur disposera de temps de travail disponible. </p>
<p>Cette m&eacute;thode permet ainsi de pouvoir g&eacute;rer une succession rapide d&rsquo;interruptions vu que le bottom-half est programm&eacute; dans tous les cas.</p>
<p><strong>Threaded interrupts : </strong>Pour permettre au syst&egrave;me de g&eacute;rer des contraintes temps r&eacute;el, le patch PREEMPT_RT met en place des <em>threaded interrupts</em>. </p>
<p>Les <em>threaded interrupts</em> reprennent le concept top-half bottom-half, mais remplacent le handler du bottom-half par un thread. Cela permet de donner une priorit&eacute; au thread et de le pr&eacute;empter si un thread avec une priorit&eacute; plus &eacute;lev&eacute; est <em>runnable</em>.</p>
<h3>H&eacute;ritage de priorit&eacute;</h3>
<p>&nbsp;&nbsp;&nbsp; Le dernier changement important &agrave; noter est l&rsquo;ajout de l&rsquo;h&eacute;ritage de priorit&eacute; pour les mutex et les spinlock. Pour illustrer l&rsquo;h&eacute;ritage de priorit&eacute; et son importance, regardons le cas suivant. </p>
<p>Tout d&rsquo;abord, sans h&eacute;ritage. On peut voir sur le sch&eacute;ma ci-dessous, que le thread 3 poss&egrave;de initialement un mutex. Le thread 1 devenant runnable, commence &agrave; ex&eacute;cuter son code jusqu&rsquo;&agrave; ce qu&rsquo;il demande le mutex tenu par le thread 3, ce qui provoque son endormissement. Le thread 3 reprend alors son ex&eacute;cution. Cependant, avant d&rsquo;avoir pu rel&acirc;cher le mutex, le scheduler le pr&eacute;empte en faveur du thread 2 qui s&rsquo;ex&eacute;cute pour une p&eacute;riode ind&eacute;finie. </p>
<p>On constate alors que le thread 1 qui a la priorit&eacute; la plus &eacute;lev&eacute;e ne pourra pas s&rsquo;ex&eacute;cuter, ce qui par cons&eacute;quent pose un probl&egrave;me lorsqu&rsquo;on fait du temps r&eacute;el du fait que le thread avec la plus grande priorit&eacute; ne s&rsquo;ex&eacute;cute pas, on appelle &ccedil;a une famine.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png" alt="" class="wp-image-6843 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png 843w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-300x164.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-768x420.png 768w" sizes="(max-width: 843px) 100vw, 843px"><figcaption>Image 4 : Exemple h&eacute;ritage de priorit&eacute; avant patch preempt RT</figcaption></figure>
</div>
<p>Dans ce second exemple avec l&rsquo;h&eacute;ritage de priorit&eacute;, on peut voir comme tout &agrave; l&rsquo;heure que le thread 3 poss&egrave;de initialement le mutex. Mais lorsque le thread 1 demande le mutex poss&eacute;d&eacute; par le thread 3, le thread 3 h&eacute;rite de la priorit&eacute; du thread 1 ce qui lui permet de rel&acirc;cher le mutex pour permettre au thread 1 de s&rsquo;ex&eacute;cuter, puis le thread 2 pourra s&rsquo;ex&eacute;cuter.&nbsp;</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png" alt="" class="wp-image-6845 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png 830w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-300x174.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-768x445.png 768w" sizes="(max-width: 830px) 100vw, 830px"><figcaption>Image 5 : Exemple h&eacute;ritage de priorit&eacute; apr&egrave;s patch preempt RT</figcaption></figure>
</div>
<h1>Impl&eacute;mentation du temps r&eacute;el sur noyau Linux</h1>
<h2>Les options du noyau Linux&nbsp;</h2>
<p>&nbsp;&nbsp;&nbsp; L&rsquo;impl&eacute;mentation du temps r&eacute;el sur noyau linux est relativement simple, mais l&rsquo;obtention de performances optimales est conditionn&eacute;e &agrave; la modification d&rsquo;options annexes. Durant les phases d&rsquo;&eacute;valuation des diff&eacute;rentes solutions temps r&eacute;el et de leurs performances, nous avons constat&eacute; que certaines options impactaient les performances plus que d&rsquo;autres.</p>
<h3>Power Management</h3>
<p>&nbsp;&nbsp;&nbsp; En contexte temps r&eacute;el, l&rsquo;important est d&rsquo;avoir un syst&egrave;me r&eacute;actif qui puisse r&eacute;agir &agrave; la moindre interruption externe au syst&egrave;me. L&rsquo;activation du power management sur le CPU cause un risque d&rsquo;augmentation de la latence du CPU. En effet, lorsque le power management est activ&eacute;, le CPU va adapter sa fr&eacute;quence pour &eacute;conomiser de l&rsquo;&eacute;nergie. </p>
<p>Cette option reste cependant int&eacute;ressante lorsque l&rsquo;on fait de l&rsquo;embarqu&eacute;, au vu de la dur&eacute;e des batteries actuelles, mais emp&ecirc;che cependant d&rsquo;obtenir des performances temps r&eacute;el. Il peut &ecirc;tre int&eacute;ressant d&rsquo;utiliser le power management sur certains c&oelig;urs (cela peut se faire au moment du boot comme pour les <a href="https://www.linuxembedded.fr/#Timers">timers</a> ci-apr&egrave;s) et d&rsquo;utiliser les autres c&oelig;urs pour toutes les t&acirc;ches temps r&eacute;els.</p>
<p>&nbsp;&nbsp;&nbsp; Pour d&eacute;sactiver le power management, il faut tout d&rsquo;abord d&eacute;sactiver le multi-core scheduler support. En effet, ce dernier nous emp&ecirc;che de retirer le power management. </p>
<ul>
<li>SCHED_MC [=n]</li>
</ul>
<div class="wp-block-image">
<figure class="aligncenter"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png" alt="" class="wp-image-7019 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png 664w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1-300x84.png 300w" sizes="(max-width: 664px) 100vw, 664px"></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Une fois le multi-core scheduler support d&eacute;sactiv&eacute;, on peut maintenant d&eacute;sactiver le CPU Frequency scaling et le CPU Idle. Le CPU Frequency scaling permet de choisir le <em>governor</em> &agrave; utiliser pour g&eacute;rer la fr&eacute;quence du CPU, ce qui est inutile dans notre cas : nous souhaitons que tous les c&oelig;urs tournent &agrave; 100% afin de maximiser les performances. En revanche, cela implique une consommation plus &eacute;lev&eacute;e. Il se peut, si vous avez un processeur qui supporte l&rsquo;ACPI, que l&rsquo;option CPU Idle ne soit pas d&eacute;sactivable, ce que traitera le paragraphe suivant.</p>
<ul>
<li>CPU_FREQ [=n]</li>
<li>CPU_IDLE [=n]</li>
</ul>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-10.png" alt="" class="wp-image-6832 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d&rsquo;&eacute;cran-du-2019-09-09-15-36-10.png 328w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d&rsquo;&eacute;cran-du-2019-09-09-15-36-10-300x48.png 300w" sizes="(max-width: 328px) 100vw, 328px"></figure>
</div>
<div class="wp-block-image">
<figure class="alignleft"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-36.png" alt="" class="wp-image-6833 img-fluid"></figure>
</div>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-50.png" alt="" class="wp-image-6834 img-fluid"></figure>
</div>
<p>Sur <strong>certains processeurs</strong>, comme ceux d&rsquo;<strong>intel</strong>, l&rsquo;ACPI (Advanced Configuration and Power Interface) g&egrave;re le <em>power management</em>. Il faut donc d&eacute;sactiver l&rsquo;ACPI seulement pour le processeur, car une d&eacute;sactivation pour d&rsquo;autres composants pourrait emp&ecirc;cher le syst&egrave;me de d&eacute;marrer correctement. De plus, sa d&eacute;sactivation est un pr&eacute;alable &agrave; celle du CPU Idle.</p>
<ul>
<li>ACPI_PROCESSOR [=n]</li>
</ul>
<div class="wp-block-image">
<figure class="aligncenter"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png" alt="" class="wp-image-7020 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png 549w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1-300x150.png 300w" sizes="(max-width: 549px) 100vw, 549px"></figure>
</div>
<h3>SMP</h3>
<p>&nbsp;&nbsp;&nbsp; Si votre syst&egrave;me ne poss&egrave;de qu&rsquo;un seul c&oelig;ur, cette section ne vous concerne pas, il faudra donc d&eacute;sactiver cette option.</p>
<p>Le SMP (Symmetric multi-processing), permet &agrave; un syst&egrave;me poss&eacute;dant plusieurs c&oelig;urs de les utiliser et donc d&rsquo;ex&eacute;cuter plusieurs t&acirc;ches &agrave; la fois. Le probl&egrave;me de poss&eacute;der plusieurs c&oelig;urs est qu&rsquo;ils partagent des zones m&eacute;moires et notamment de la m&eacute;moire cache L2 (cela d&eacute;pend de l&rsquo;architecture du processeur). Le fait de partager de la m&eacute;moire augmente le temps d&rsquo;acc&egrave;s &agrave; la zone m&eacute;moire. Pour &eacute;viter ce probl&egrave;me, il est conseill&eacute; de bien g&eacute;rer les affinit&eacute;s des t&acirc;ches et des processus. Pour activer le multi-processing il suffit de choisir l&rsquo;option Symmetric multi-processing support.</p>
<ul>
<li>SMP [=y]</li>
</ul>
<h3 id="Timers">Timers</h3>
<p>&nbsp;&nbsp;&nbsp; Ensuite, nous devons param&eacute;trer les timers pour obtenir une plus grande r&eacute;activit&eacute;. Tout d&rsquo;abord, il faut activer le timer haute r&eacute;solution qui fournit une meilleure pr&eacute;cision pour tous nos programmes user-space.</p>
<ul>
<li>HIGH_RES_TIMERS [=y]</li>
</ul>
<div class="wp-block-image">
<figure class="aligncenter"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png" alt="" class="wp-image-7021 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png 785w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-300x30.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-768x76.png 768w" sizes="(max-width: 785px) 100vw, 785px"></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Ensuite, pour &eacute;viter au syst&egrave;me de se mettre en veille, il faut laisser les timers interrompre le syst&egrave;me p&eacute;riodiquement afin de ne pas manquer d&rsquo;&eacute;v&eacute;nements importants. Il faut donc modifier l&rsquo;option Timer tick handling comme on peut le voir ci-dessous, et choisir l&rsquo;option <strong>Periodic timer ticks.</strong> Il peut &ecirc;tre int&eacute;ressant de choisir cette option pour certains c&oelig;urs, dans ce cas il faudra donner les options de<em> boot </em>suivantes pour isoler les c&oelig;urs et les rendre <em>tickless</em> : <em>&laquo;&nbsp;isolcpus=2,3 nohz_full=2,3&nbsp;&raquo;</em></p>
<ul>
<li>HZ_PERIODIC [=y]</li>
</ul>
<div class="wp-block-image">
<figure class="aligncenter"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png" alt="" class="wp-image-7022 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png 618w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1-300x150.png 300w" sizes="(max-width: 618px) 100vw, 618px"></figure>
</div>
<hr class="wp-block-separator">
<h2>Les impacts sur le d&eacute;veloppement applicatif et le syst&egrave;me</h2>
<h3>Affinit&eacute;s</h3>
<p>&nbsp;&nbsp;&nbsp; Lorsque l&rsquo;on fait du temps r&eacute;el sous linux, il est important de g&eacute;rer l&rsquo;affinit&eacute; de ses t&acirc;ches et des interruptions. </p>
<p>La premi&egrave;re chose &agrave; faire, surtout si l&rsquo;on est en SMP, est de modifier l&rsquo;affinit&eacute; des interruptions du syst&egrave;me dans /proc/interrupts pour emp&ecirc;cher les migrations de c&oelig;ur qui augmentent la latence. Il est pr&eacute;f&eacute;rable de regrouper certaines interruptions sur le m&ecirc;me CPU pour r&eacute;server les autres CPUs &agrave; notre application temps r&eacute;el. </p>
<p>Pour modifier l&rsquo;affinit&eacute; d&rsquo;une interruption, il faut modifier le pseudo-fichier <em>/proc/irq/&lt;NumeroIRQ&gt;/smp_affinity</em> &agrave; l&rsquo;aide de la commande :<em>&laquo;&nbsp;echo 8 &gt; /proc/irq/127/smp_affinity&nbsp;&raquo;</em> pour par exemple mettre l&rsquo;interruption 127 sur le CPU 4. Ce fichier contient en effet un masque binaire d&eacute;finissant le ou les cpus &agrave; utiliser en cas d&rsquo;interruption. Par exemple 0001 repr&eacute;sente le CPU 0 tandis que 1001 repr&eacute;sente les CPUs 0 et 4. Il est important de noter que le fichier <em>/proc/irq/NumeroIRQ/smp_affinity</em> attend une valeur en hexad&eacute;cimal, ce qui explique la valeur 8 pr&eacute;c&eacute;dente.</p>
<p>On peut voir ci-dessous les interruptions et leur nombre d&rsquo;occurences sur chaque cpu de ma raspberry pi 4 &agrave; l&rsquo;aide de la commande <em>&laquo;&nbsp;cat /proc/interrupts&nbsp;&raquo;</em>.</p>
<figure class="wp-block-image"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png" alt="" class="wp-image-7023 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-300x81.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-768x207.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1.png 1032w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 6 : R&eacute;sultat de la commande &laquo;&nbsp;cat /proc/interrrupts&nbsp;&raquo;</figcaption></figure>
<p>&nbsp;&nbsp;&nbsp; Lors du d&eacute;veloppement applicatif d&rsquo;une solution temps r&eacute;el, il est important de bien choisir l&rsquo;affinit&eacute; de ses threads et de son processus principal. Pour les threads, il existe la fonction <strong><em>pthread_attr_setaffinity_np()</em></strong> et pour le processus principal, on peut utiliser la commande <strong><em>taskset </em></strong>ou la fonction <strong><em>sched_setaffinity().&nbsp;</em></strong></p>
<p><strong><em>&nbsp;&nbsp;&nbsp; </em></strong>Pour v&eacute;rifier l&rsquo;utilisation de chaque thread de son programme, on peut utiliser la commande suivante : &ldquo;<em>watch -n 1 ps -p $(pidof monProgramme) -L -o pid,tid,psr,pcpu,comm</em>&rdquo;. Cela permet de lister pour un PID donn&eacute;, tous les threads pr&eacute;sents et d&rsquo;afficher sur quel c&oelig;ur ils s&rsquo;ex&eacute;cutent. On peut voir ci-dessous le r&eacute;sultat de cette commande sur un programme personnel.</p>
<p>La colonne PID repr&eacute;sente le PID du programme, le TID celui du thread, PSR indique sur quel c&oelig;ur le thread s&rsquo;ex&eacute;cute et %CPU sa consommation CPU. Enfin, la colonne COMMAND permet de conna&icirc;tre le nom du thread si vous avez utilis&eacute; la fonction<strong><em> pthread_setname_np()</em></strong>.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png" alt="" class="wp-image-7024 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png 315w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6-300x229.png 300w" sizes="(max-width: 315px) 100vw, 315px"><figcaption>Image 7 : R&eacute;sultat de la commande &laquo;&nbsp;watch -n 1 ps -p $(pidof cam) -L -o pid,tid,psr,pcpu,comm&nbsp;&raquo;</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Il est recommand&eacute; de bien conna&icirc;tre l&rsquo;architecture de son processeur, et d&rsquo;&eacute;tablir un plan d&rsquo;affectation des ressources : laisser un c&oelig;ur pour le syst&egrave;me (le coeur 0), et r&eacute;partir les activit&eacute;s sur les autres c&oelig;urs.</p>
<h3><em>Real Time Throttling</em></h3>
<p>Lorsque vous ex&eacute;cutez une application temps r&eacute;el sur un syst&egrave;me temps r&eacute;el, par d&eacute;faut le syst&egrave;me ne donne pas acc&egrave;s &agrave; 100% du CPU. En effet, le <em>scheduler</em> temps r&eacute;el ne permet &agrave; un processus que de consommer 95% du temps CPU. Ces param&egrave;tres sont r&eacute;gis par les pseudo fichiers suivants :</p>
<ul>
<li> <em>/proc/sys/kernel/sched_rt_period_us</em></li>
<li><em> /proc/sys/kernel/sched_rt_runtime_us</em></li>
</ul>
<p>Ces param&egrave;tres permettent d&rsquo;allouer un temps de s<em>ched_rt_runtime_us</em> sur une p&eacute;riode de <em>sched_rt_period_us</em>. Par d&eacute;faut ce ratio vaut <em>950000 &micro;s</em>/100000 <em>&micro;s</em>, soit 95%. Cela permet d&rsquo;&eacute;viter qu&rsquo;une application erron&eacute;e ne prenne tout le CPU et emp&ecirc;che le syst&egrave;me de r&eacute;agir &agrave; d&rsquo;autres &eacute;v&eacute;nements.</p>
<p>En revanche, il peut &ecirc;tre int&eacute;ressant sur un syst&egrave;me valid&eacute; d&rsquo;optimiser ce ratio, voire de d&eacute;sactiver cette option en mettant -1 dans <em>/proc/sys/kernel/sched_rt_period_us</em> ou en r&eacute;glant <em>sched_rt_period_us = sched_rt_runtime_us</em> : <em>&laquo;&nbsp;echo -1 &gt; /proc/sys/kernel/sched_rt_period_us&nbsp;&raquo;</em>.</p>
<h1>Performances</h1>
<p>Afin de mesurer les performances des diff&eacute;rentes solutions temps r&eacute;el, j&rsquo;ai utilis&eacute; les outils suivants :&nbsp;</p>
<ul>
<li>Un script lan&ccedil;ant des <em>cyclictest</em> avec un ordonnancement<em> </em>SCHED_OTHER, SCHED_RR (round-robin) et SCHED_FIFO avec une priorit&eacute; de 99, subissant une charge simul&eacute;e par le programme <em>stress</em>. Chaque test a &eacute;t&eacute; jou&eacute; durant une heure.</li>
<li>Un programme cod&eacute; en C calculant le temps de commutation d&rsquo;un thread &agrave; l&rsquo;autre au moment de l&acirc;cher un mutex, sous charge et sans charge, sur m&ecirc;me CPU. Chaque test prenant en compte 10000 commutations.</li>
</ul>
<p>J&rsquo;ai r&eacute;alis&eacute; ces tests sur les syst&egrave;mes suivants : </p>
<ol>
<li><strong>x86_64</strong>
<ol>
<li><em>Linux vanilla 4.14.71</em></li>
<li><em>Linux vanilla 4.14.71 PREEMPT_RT</em></li>
<li><em>Xenomai Cobalt 3.0.8 sous linux vanilla 4.14.71</em></li>
<li><em>Xenomai Mercury 3.0.8 sous linux vanilla 4.14.71 PREEMPT_RT</em></li>
</ol>
</li>
<li><strong>Raspberry pi 3B, arm 64bits</strong>
<ol>
<li><em>Linux rpi 4.14.71</em></li>
<li><em>Linux rpi 4.14.71 PREEMPT_RT</em></li>
<li><em>Xenomai Cobalt 3.0.8 sous linux rpi 4.14.71</em></li>
<li><em>Xenomai Mercury 3.0.8 sous linux rpi 4.14.71 PREEMPT_RT</em></li>
</ol>
</li>
</ol>
<h3>Cyclictest</h3>
<p>&nbsp;&nbsp;&nbsp; Tout au long de cette partie, je ne vais parler que de l&rsquo;ordonnancement SCHED_FIFO car ses performances sont quasi &eacute;quivalentes &agrave; celles de l&rsquo;ordonnancement round-robin, et l&rsquo;ordonnancement SCHED_OTHER ne concerne pas le temps r&eacute;el.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png" alt="" class="wp-image-6904 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 8 : R&eacute;sultats cyclictest sur raspberry pi 3B</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; On peut voir sur cette premi&egrave;re s&eacute;rie de benchmarks les diff&eacute;rences entre les diff&eacute;rents syst&egrave;mes. On remarque que seul le kernel linux classique d&eacute;passe les 400 &micro;s de latences et que les autres ne d&eacute;passent pas les 100 &micro;s. Attention cependant, sur le kernel normal, il y a des pics en dehors du graphique &agrave; plus de 10000 &micro;s comme indiqu&eacute; sur le graphique, ce qui pose donc le probl&egrave;me du d&eacute;terminisme du syst&egrave;me. Avec les trois autres syst&egrave;mes, le max ne d&eacute;passe pas les 100 &micro;s.</p>
<p>&nbsp;&nbsp;&nbsp; On peut ensuite voir que les performances sont sensiblement &eacute;quivalentes entre un syst&egrave;me sous Xenomai Mercury et un syst&egrave;me patch&eacute; PREEMPT RT. Enfin la meilleure performance vient du syst&egrave;me sous Xenomai Cobalt qui affiche une latence maximale sous les 10 &micro;s avec une moyenne bien plus basse que les 2 autres, <strong><em>et les latences semblent mieux born&eacute;es.</em></strong></p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png" alt="" class="wp-image-6905 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 9 : R&eacute;sultats cyclictest sur x86_64</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Passons maintenant sous x86_64, on peut voir que le m&ecirc;me ordre est respect&eacute;, sauf pour Xenomai Mercury qui pr&eacute;sente de moins bonnes performances que ses concurrents. Comme tout &agrave; l&rsquo;heure le test sous linux 4.14.71 non pr&eacute;emptible r&eacute;v&egrave;le des pics &agrave; plus de 10000 &micro;s comme indiqu&eacute; sur le graphique qui sortent de la port&eacute; du graphique.</p>
<h3>Commutations de threads</h3>
<p>&nbsp;&nbsp;&nbsp; Afin de mesurer les performances de commutations, j&rsquo;ai cod&eacute; un petit programme qui calcule le temps que met le cpu pour changer de thread. Le principe du programme est le suivant : le thread 1 prend un mutex, puis le rel&acirc;che. Le scheduler est appel&eacute; et le thread 2 se lance en prenant le mutex. Le temps s&eacute;parant la fin du thread 1 du d&eacute;but du thread 2 est mesur&eacute; et stock&eacute; dans une variable globale prot&eacute;g&eacute;e par le mutex. Au bout de 10000 mesures, le r&eacute;sultat est affich&eacute;.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png" alt="" class="wp-image-6861 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png 620w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation-300x120.png 300w" sizes="(max-width: 620px) 100vw, 620px"><figcaption>Image 10 : Exemple temps de commutations entre deux threads</figcaption></figure>
</div>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png" alt="" class="wp-image-6868 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 11 : R&eacute;sultats commutations de threads sur raspberry pi 3B</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Les r&eacute;sultats ci-dessus montrent les diff&eacute;rences de performances sur Raspberry Pi sous stress. On peut voir que les performances entre un linux non patch&eacute; et patch&eacute; PREEMPT_RT sont assez similaires, avec une valeur max de 90 &micro;s. En revanche on peut voir un r&eacute;sultat assez &eacute;trange : les moins bonnes performances sont atteintes par Xenomai Mercury. Enfin, Xenomai Cobalt obtient les meilleures performances.</p>
<div class="wp-block-image">
<figure class="aligncenter"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png" alt="" class="wp-image-6869 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 12 : R&eacute;sultats commutations de threads sur x86_64</figcaption></figure>
</div>
<p>&nbsp;&nbsp;&nbsp; Passons maintenant sur x86_64, nous observons sensiblement les m&ecirc;mes r&eacute;sultats que sur arm64, avec toujours un retard de performance pour Xenomai Mercury.</p>
<h3>Diff&eacute;rences entre POSIX et Alchemy (Xenomai)</h3>
<p>&nbsp;&nbsp;&nbsp; Xenomai propose des skins, qui sont de petits wrappers permettant d&rsquo;utiliser des APIs venant d&rsquo;autres syst&egrave;mes comme VxWorks ou POSIX avec Xenomai. La librairie native &agrave; xenomai est la librairie Alchemy qui est assez compl&egrave;te et fournit des outils tr&egrave;s utiles comme des queues optimis&eacute;es, des buffers, des pipes, des s&eacute;maphores etc&hellip;</p>
<p>&nbsp;&nbsp;&nbsp; Nous allons voir la diff&eacute;rence de performance entre les deux skins POSIX et Alchemy, gr&acirc;ce &agrave; un portage du programme r&eacute;alis&eacute; pour la commutation de threads sous les deux librairies. Voici ci-dessous les performances sous Xenomai Mercury. On peut voir un petit gain de performance avec la librairie native.</p>
<figure class="wp-block-image"><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png" alt="" class="wp-image-6870 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-300x113.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-768x288.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 13 : R&eacute;sultats commutations de threads sur raspberry pi 3B, diff&eacute;rences APIs POSIX vs Alchemy</figcaption></figure>
<h1>&nbsp;Conclusion</h1>
<p>&nbsp;&nbsp;&nbsp; Pour conclure, nous constatons avec &eacute;vidence que Xenomai Cobalt est la meilleure des solutions pour faire du Linux temps r&eacute;el avec des contraintes hard real time. Cependant, nous pouvons voir que le patch PREEMPT_RT propose une solution plus facile &agrave; mettre en place que Xenomai et pr&eacute;sente de tr&egrave;s bonnes caract&eacute;ristiques temps r&eacute;el, qui ont vu une nette am&eacute;lioration r&eacute;cemment.</p>
<p>&nbsp;&nbsp;&nbsp; On remarque par contre des r&eacute;sultats un peu &eacute;tonnants sur Xenomai Mercury qui affiche des performances plus faibles que ses concurrents. Encore une fois, les tests r&eacute;alis&eacute;s ne sont pas pr&eacute;cis &agrave; 100% au vu de leur dur&eacute;e et du nombre de tests r&eacute;alis&eacute;s, en raison d&rsquo;un manque de temps.</p>
<p>Pour ce qui est de Xenomai et comment l&rsquo;impl&eacute;menter de mani&egrave;re optimale, voici en lien le wiki de Xenomai qui est tr&egrave;s bien document&eacute; :</p>
<p><a href="https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here">https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here</a></p>
<p>&nbsp;&nbsp;&nbsp; De plus, j&rsquo;ai expos&eacute; ici quelques options &agrave; activer/d&eacute;sactiver au niveau du kernel, mais la configuration optimale d&eacute;pendra de l&rsquo;architecture utilis&eacute;e et des contraintes li&eacute;es au produit. Si vous &ecirc;tes int&eacute;ress&eacute;, vous pouvez consulter le site ci-dessous d&eacute;crivant toutes les subtilit&eacute;s et les am&eacute;liorations &agrave; faire pour mettre en place du temps r&eacute;el : </p>
<p><a href="http://linuxrealtime.org/index.php/Main_Page">http://linuxrealtime.org/index.php/Main_Page</a></p>
<p>&nbsp;&nbsp;&nbsp; Je vous partage &eacute;galement deux vid&eacute;os int&eacute;ressantes sur le patch PREEMPT_RT :</p>
<ul>
<li><em>Real Time is Coming to Linux; What Does that Mean to You? &ndash; Steven Rostedt, VMware</em></li>
</ul>
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio">
<div class="wp-block-embed__wrapper">
<iframe title="Real Time is Coming to Linux; What Does that Mean to You? - Steven Rostedt, VMware" width="1170" height="658" src="https://www.youtube.com/embed/BxJm-Ujipcg?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</figure>
<ul>
<li><em>Embedded Linux Conference 2013 &ndash; Inside the RT Patch </em></li>
</ul>
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio">
<div class="wp-block-embed__wrapper">
<iframe title="Embedded Linux Conference 2013 - Inside the RT Patch" width="1170" height="658" src="https://www.youtube.com/embed/n9ucTGWrON8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</figure>
<ul>
<li><em>Introduction to Realtime Linux</em></li>
</ul>
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio">
<div class="wp-block-embed__wrapper">
<iframe title="Introduction to Realtime Linux" width="1170" height="658" src="https://www.youtube.com/embed/BKkX9WASfpI?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</figure>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>My first Linux kernel built with Clang compiler!</title>
		<link>https://dev-pro.xyz/blog/my-first-linux-kernel-built-with-clang-compiler/</link>
				<pubDate>Fri, 27 Dec 2019 15:50:32 +0000</pubDate>
		<dc:creator><![CDATA[siz]]></dc:creator>
				<category><![CDATA[clang]]></category>
		<category><![CDATA[HowTo]]></category>
		<category><![CDATA[kernel]]></category>
		<category><![CDATA[Linux]]></category>

		<guid isPermaLink="false">https://dev-pro.xyz/blog/my-first-linux-kernel-built-with-clang-compiler/</guid>
				<description><![CDATA[Following his internship at Smile in 2018 on LLVM/Clang integration into Buildroot [1], Valentin Korenblit still maintains these packages on his spare time (thanks to him!), up to the latest current version llvm/Clang 8.0.0. At the same time the Linux kernel continues evolving to support Clang compiler thanks to Google engineers. See Phoronix article [2] ... <a href="https://dev-pro.xyz/blog/my-first-linux-kernel-built-with-clang-compiler/" class="more-link text-uppercase small"><strong>Continue Reading</strong> <i class="fa fa-angle-double-right" aria-hidden="true"></i></a>]]></description>
								<content:encoded><![CDATA[<div>
<p>Following his internship at Smile in 2018 on LLVM/Clang integration into Buildroot [1], Valentin Korenblit still maintains these packages on his spare time (thanks to him!), up to the latest current version llvm/Clang 8.0.0.</p>
<p>At the same time the Linux kernel continues evolving to support Clang compiler thanks to Google engineers. See Phoronix article [2] and &laquo;&nbsp;Compiling the Linux kernel with LLVM tools&nbsp;&raquo; conference at FOSDEM 2019 [3].</p>
<p>Valentin stated in his internship report:</p>
<blockquote class="wp-block-quote">
<p>Clang was designed to offer GCC compatibility, so it accepts most of GCC&rsquo;s command line arguments to specify the compiler options. However, GCC offers a lot of extensions to the standard language while Clang&rsquo;s purpose is being standard-compliant. Because of this, Clang cannot be a replacement for GCC when compiling projects that depend on GCC extensions, as it happens with Linux kernel. In this case, Linux can&rsquo;t be built because Clang does not accept the following kinds of constructs:</p>
<p>&bull; Variable length arrays inside structures<br />&bull; Nested Functions<br />&bull; Explicit register variables</p>
<p>Furthermore, Linux kernel still depends on GNU assembler and linker.</p>
<p><cite>http://www.linuxembedded.fr/2018/07/llvmclang-integration-into-buildroot/</cite></p></blockquote>
<p>In order to check by ourselves if it is now possible to compile a kernel with Clang using buildroot, we will compile the aarch64 configuration for Qemu (qemu_aarch64_virt_defconfig).<br />First, we will try with the GCC toolchain in order to verify that everything works fine. Then we will recompile the kernel with Clang.</p>
<pre class="wp-block-preformatted">$ make qemu_aarch64_virt_defconfig</pre>
<p>In order to speedup the build, we use an prebuilt external toolchain (Arm AArch64 2019.03) instead of an internal toolchain. We could also use an aarch64 toolchain downloaded from toolchain-builder project (<a href="https://toolchains.bootlin.com/">https://toolchains.bootlin.com</a>) that provide several toolchains generated by Buildroot.</p>
<p>When the build is finished, we can test the system using Qemu as indicated in the file &laquo;&nbsp;board/qemu/aarch64-virt/readme.txt&nbsp;&raquo;</p>
<p>The system should boot correctly.<br />(If not, check your Qemu version and make sure it&rsquo;s at least at the same version as the one present in the readme.txt).</p>
<p>Now that we tested that the kernel build correctly with GCC, we are going to try again with Clang. To do that, we first clean the kernel&rsquo;s build directory</p>
<pre class="wp-block-preformatted">$ make linux-dirclean</pre>
<p>Note: We keep the user space content previously built by the GCC toolchain.<br />Building user space programs using Clang is not supported yet by buildroot.</p>
<p>We then need to build the Clang compiler itself. This is done by the host-clang package</p>
<p>We cannot select host-clang in buildroot&rsquo;s menuconfig, because host-clang can only be selected as a dependency of another package. We will simply trigger the host-clang build manually</p>
<pre class="wp-block-preformatted">$ make host-clang</pre>
<p>In order to cross-compile the kernel, we have to modify the Linux&rsquo;s package Makefile (linux/linux.mk) as suggested in the following patch.</p>
<div class="wp-block-file"><a href="http://www.linuxembedded.fr/wp-content/uploads/2019/08/0001-linux-compile-with-clang.patch_.zip">0001-linux-compile-with-clang.patch</a></div>
<p>Now it&rsquo;s time to rebuild the kernel using Clang <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="&#128578;" class="wp-smiley img-fluid" style="height: 1em; max-height: 1em;"><br />Note: By default the qemu_aarch64_virt_defconfig uses a kernel 4.19.x, it&rsquo;s recommended to use the latest kernel version (5.2.7).</p>
<pre class="wp-block-preformatted">$ make linux</pre>
<p>The kernel build takes some time to complete, you can check the list of processes running on you build machine thanks to the htop command. You should notice some activity with clang-8 process.</p>
<p>When the build is finished (and successful), restart Qemu using the same command line as before.</p>
<p>The system should boot successfully and you can check the dmesg output to know the compiler used to build the kernel.</p>
<figure class="wp-block-image"><img class="wp-image-6720 img-fluid" src="http://www.linuxembedded.fr/wp-content/uploads/2019/08/Linux_kernel_built_with_clang_2019-08-06_22-02-50.png" alt="" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/08/Linux_kernel_built_with_clang_2019-08-06_22-02-50.png 970w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/Linux_kernel_built_with_clang_2019-08-06_22-02-50-300x110.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/08/Linux_kernel_built_with_clang_2019-08-06_22-02-50-768x283.png 768w" sizes="(max-width: 970px) 100vw, 970px"></figure>
<h2>Conclusion:</h2>
<p>This is our first test with a Linux kernel with Clang cross-compiler, for now it&rsquo;s just a hack in Buildroot&rsquo;s linux package.<br />Buildroot is not able to use Clang as a generic compiler for all user-space yet. Adding this feature requires discussion with the Buildroot community.</p>
<p>This support would also require to change some hard-coded references within the Buildroot&rsquo;s package infrastructure. CMake and meson cross-compilation support, in particular, would need some work.</p>
<p>Buildroot probably needs a new toolchain-wrapper for Clang compiler to provide &ndash;sysroot path and other compiler options like it does for the GCC cross-toolchain.<br />Since the Clang compiler take a lot of time to build, it would be interesting to be able to reuse a prebuilt Clang compiler and import it in the toolchain-external package infrastructure. This would require that LLVM/Clang binaries be relocatable.<br />For now, only aarch64 kernel has been tested since it probably the most tested one with Clang [5]. It would be interesting to do further tests with other architectures like arm, x86, x86_64, mips, mips64, ppc, ppc64&hellip;</p>
<p>References:</p>
<p>[1] <a href="http://www.linuxembedded.fr/2018/07/llvmclang-integration-into-buildroot">http://www.linuxembedded.fr/2018/07/llvmclang-integration-into-buildroot</a><br />[2] <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Google-2019-Clang-Kernel">https://www.phoronix.com/scan.php?page=news_item&amp;px=Google-2019-Clang-Kernel</a><br />[3] <a href="https://fosdem.org/2019/schedule/event/llvm_kernel/attachments/slides/3330/export/events/attachments/llvm_kernel/slides/3330/clang_linux_fosdem_19.pdf">https://fosdem.org/2019/schedule/event/llvm_kernel/attachments/slides/3330/export/events/attachments/llvm_kernel/slides/3330/clang_linux_fosdem_19.pdf</a><br />[4] <a href="https://www.elinux.org/Buildroot:DeveloperDaysFOSDEM2018#LLVM.2FClang">https://www.elinux.org/Buildroot:DeveloperDaysFOSDEM2018#LLVM.2FClang</a><br />[5] <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Clang-Kernel-2018">https://www.phoronix.com/scan.php?page=news_item&amp;px=Clang-Kernel-2018</a></p>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
