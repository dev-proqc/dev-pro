<!DOCTYPE html>
<html lang="fr-CA" class="no-js"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script>(function(html){html.className = html.className.replace(/\bno-js\b/,'js')})(document.documentElement);</script><link media="all" href="https://dev-pro.xyz/blog/wp-content/cache/autoptimize/css/autoptimize_3856cada20bef986579d474c88d62b88.css" rel="stylesheet"><title>Le Temps Reel sous Linux – Dev-Pro Informatique</title><script type="text/javascript" src="https://dev-pro.xyz/blog/wp-includes/js/jquery/jquery.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
                     google_ad_client: "ca-pub-1370898179955590",
                     enable_page_level_ads: true
                });</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-154856998-1"></script><script>window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'UA-154856998-1');</script></head><body class="post-template-default single single-post postid-233 single-format-standard wp-custom-logo"><div class="body-wrap fullwidth-container"><nav class="navbar navbar-light bg-white border-bottom navbar-expand-lg justify-content-between px-5 py-4 fullwidth-container"><div class="navbar-brand py-0 mb-0"> <a href="https://dev-pro.xyz/blog/" class="custom-logo-link" rel="home"><noscript><img width="132" height="29" src="https://dev-pro.xyz/blog/wp-content/uploads/2019/12/logo.png" class="custom-logo" alt="Dev-Pro Informatique"></noscript><img width="132" height="29" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20132%2029%22%3E%3C/svg%3E" data-src="https://dev-pro.xyz/blog/wp-content/uploads/2019/12/logo.png" class="lazyload custom-logo" alt="Dev-Pro Informatique"></a> <a href="https://dev-pro.xyz/blog/" title="Dev-Pro Informatique" rel="home" class="site-title text-dark">Dev-Pro Informatique</a></div> <span class="navbar-text site-description text-info small d-none d-md-block">Solution Technologique</span> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle Navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbar-content"><ul id="primary-menu" class="navbar-nav ml-auto"><li id="menu-item-62" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-62 nav-item"><a href="https://dev-pro.xyz/blog/acceuil/" class="nav-link">Accueil</a></li></ul></div></nav><div class="container my-lg-5 my-sm-3"><div class="row"><div class="col-md-12 col-lg-8"><div class="content my-5"><article id="post-233" class="mb-5 post-233 post type-post status-publish format-standard hentry category-kernel category-linux category-preempt-rt category-technologie category-temps-reel category-whitepaper category-xenomai"><p class="text-uppercase mb-1"><a href="https://dev-pro.xyz/blog/category/kernel/" rel="category tag">kernel</a>, <a href="https://dev-pro.xyz/blog/category/linux/" rel="category tag">Linux</a>, <a href="https://dev-pro.xyz/blog/category/preempt-rt/" rel="category tag">preempt-rt</a>, <a href="https://dev-pro.xyz/blog/category/technologie/" rel="category tag">Technologie</a>, <a href="https://dev-pro.xyz/blog/category/temps-reel/" rel="category tag">temps réel</a>, <a href="https://dev-pro.xyz/blog/category/whitepaper/" rel="category tag">WhitePaper</a>, <a href="https://dev-pro.xyz/blog/category/xenomai/" rel="category tag">Xenomai</a></p><h2 class="entry-title"><a href="https://dev-pro.xyz/blog/le-temps-reel-sous-linux/" rel="bookmark">Le Temps Reel sous Linux</a></h2><p class="meta text-muted text-info small"> By <a href="https://dev-pro.xyz/blog/author/siz/">siz</a> on décembre 27, 2019 <span>•</span> 0 Comments</p><div class="clearfix"></div><div class="entry"><div><p>Dans cet article, nous allons discuter de l’intérêt ainsi que des avantages et inconvénients d’utiliser un noyau Linux temps réel. L’objectif de cet article n’est pas de décrire ce qu’est le temps réel mais pourquoi et comment l’utiliser. <br>Aux lecteurs curieux et intéressés par le temps réel, je recommande le livre de<strong><em> </em></strong>Christophe Blaess, <em>Solutions temps réel sous Linux</em>.</p><h1>Introduction</h1><h3>Historique</h3><p>La notion de temps réel a commencé à apparaître dans les années 60 dans le domaine de l’aérospatial. En effet, l’un des premiers systèmes embarqués temps réel fut l’Apollo Guidance Computer conçu par le MIT permettant du traitement temps réel des données recueillies lors du vol. La notion de temps réel a cependant bien évolué jusqu’à maintenant.</p><p>De nos jours, de nombreux systèmes requièrent des performances dites temps réel. En effet, le marché des systèmes embarqués est en pleine croissance et le besoin de solutions embarquées temps réel augmente en conséquence. Le temps réel se retrouve en particulier dans les domaines suivants :</p><ul><li>Automobile</li><li>Automatique industrielle </li><li>Télécommunications</li><li>Santé/Médical</li><li>Aéronautique/Aérospatial</li></ul><h3>Qu’est ce que le temps réel ?</h3><p>    Il ne faut pas confondre temps réel avec vitesse. Par exemple le système de commande d’un avion nécessitera un temps de réponse de l’ordre de la microseconde alors le système de contrôle d’une chaîne de production nécessitera un temps de réponse de l’ordre de la milliseconde. En revanche, il devront tous deux répondre dans un laps de temps défini et ne pas le dépasser.</p><p>Il existe plusieurs notions de temps réel : <strong>Le temps réel strict (hard real time) et le temps réel souple (soft real time). </strong></p><p>    Le temps réel strict pénalise le non-respect d’une échéance par l’émission d’une erreur. La réponse du système est donc considérée comme erronée. En revanche un temps réel souple tolère une certaine marge de dépassement.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png" alt="" class="wp-image-6902 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png 625w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple-300x64.png 300w" sizes="(max-width: 625px) 100vw, 625px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png" alt="" class="lazyload wp-image-6902 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple.png 625w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/TR_strict_vs_souple-300x64.png 300w" data-sizes="(max-width: 625px) 100vw, 625px"><figcaption>Image 1 : Différence soft (droite) et hard (gauche) real time</figcaption></figure></div><h3>Les solutions temps réel</h3><p>    Plusieurs solutions temps réel sont disponibles aujourd’hui, propriétaires comme libres. En voici quelques exemples :</p><ul><li>FreeRTOS</li><li>QNX</li><li>VxWorks</li></ul><hr class="wp-block-separator"><p>On peut ensuite lister les solutions avec noyaux hybrides qui présentent d’autres avantages. Certaines de ces solutions permettent d’utiliser un noyau Linux et d’y installer à côté un noyau temps réel. On peut citer :</p><ul><li>Xenomai (Cobalt), Xenomai Mercury est simplement l’utilisation de l’API Xenomai sur un noyau Linux patché PREEMPT_RT.</li><li>RTAI</li></ul><p>Xenomai se distingue par ses performances ainsi que la possibilité d’utiliser son API sans avoir obligatoirement à utiliser son co-noyau Xenomai Cobalt. A cet effet, Xenomai se décline en deux versions : Cobalt (co-noyau) et Mercury.</p><p>Cobalt est la version la plus intéressante si l’on veut faire du temps réel strict. Cobalt utilise le patch I-pipe qui installe un pipeline redistribuant les interruptions entre le noyau linux (pour les interruptions non temps réel) et le noyau Cobalt (pour les interruptions temps réel). Attention cependant, il est important de regarder la compatibilité du patch avec le matériel utilisé.</p><p>Mercury lui, permet d’utiliser l’API Xenomai sur un noyau linux patché PREEMPT_RT. Mercury est plus simple à implémenter que Cobalt mais reste moins performant.</p><hr class="wp-block-separator"><p>    Le noyau Linux mainline quant à lui possède quelques briques de base nécessaire au temps réel, comme par exemple un scheduler qui propose des politiques de scheduling temps réel.</p><p>En effet, dans les options de kernel, on peut choisir la préemptibilité du noyau linux. Par défaut, seulement 3 options sont disponibles, la meilleure de ces trois options pour s’approcher d’un comportement temps réel étant la préemptibilité Low-Latency. Cependant si l’on veut vraiment faire du temps réel, il faudra se tourner vers d’autres solutions.</p><p>Il est possible d’ajouter deux autres options de configuration en patchant le kernel à l’aide du patch PREEMPT_RT. Ce patch n’est actuellement pas pris en charge par le kernel mainline mais est en bonne voie pour devenir partie intégrante du kernel dans les mois ou les années à venir.</p><figure class="wp-block-image"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png" alt="" class="wp-image-6938 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-300x171.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-768x437.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt.png 1040w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png" alt="" class="lazyload wp-image-6938 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-1024x583.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-300x171.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt-768x437.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Preempt_rt.png 1040w" data-sizes="(max-width: 1024px) 100vw, 1024px"></figure><p>    Nous allons maintenant parcourir les changements introduits par le patch PREEMPT_RT, évaluer les performances des différentes solutions temps réel sous Linux et évoquer des exemples d’implémentation de temps réel sous linux.</p><hr class="wp-block-separator"><h1>Apports du patch PREEMPT_RT</h1><p>    Le patch PREEMPT_RT ajoute l’option de compilation du noyau CONFIG_PREEMPT_RT_FULL. Elle se traduit par l’ajout de lignes dans le code du kernel, de type :</p><pre class="wp-block-code"><code>#ifdef CONFIG_PREEMPT_RT_FULL
<code modifié RT>
#else
<code vanilla>
#endif</code></pre><p>    Le principe du patch PREEMPT RT est d’autoriser la préemption partout même dans les interruptions, à l’aide de l’ajout des mécanismes  que nous allons décrire ci-après.</p><h3>Spinlock et Mutex</h3><p>    Dans le patch PREEMPT_RT, l’intérêt est de pouvoir préempter toutes les tâches, mêmes celles possédant un spinlock, pour laisser s’exécuter la tâche la plus prioritaire. Dans cette optique, le rôle du patch est donc de transformer les spinlocks actuels en sleeping spinlocks, soit en rt_mutex. En effet, les spinlocks ne sont pas préemptibles par défaut, ce qui peut poser problème lorsqu’on fait du temps réel.</p><p>On peut le voir dans le fichier <em><spinlock_types.h></em> :</p><pre class="wp-block-code"><code>#include <linux/spinlock_types_raw.h>

#ifndef CONFIG_PREEMPT_RT_FULL
# include <linux/spinlock_types_nort.h>
# include <linux/rwlock_types.h>
#else
# include <linux/rtmutex.h>
# include <linux/spinlock_types_rt.h>
# include <linux/rwlock_types_rt.h>
#endif</code></pre><p>Et dans le fichier <em><linux/spinlock_types_rt.h></em> :</p><pre class="wp-block-code"><code>typedef struct spinlock {
    struct rt_mutex        lock;
    unsigned int        break_lock;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
    struct lockdep_map    dep_map;
#endif
} spinlock_t;</code></pre><p>    Voici ci-dessous le fonctionnement des spinlocks dans un kernel mainline. Prenons l’exemple d’un programme possédant deux threads, tout deux s’exécutant sur un même coeur. Le premier thread (VERT), se lance jusqu’à rencontrer une zone de code protégée par un spinlock. Pendant ce temps, le thread 2 (BLEU), plus prioritaire est prêt à s’exécuter mais comme le thread 1 est dans un spinlock, le thread 2 devra attendre la fin de la zone de code protégée par un spinlock.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png" alt="" class="wp-image-6839 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png 792w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-300x92.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-768x237.png 768w" sizes="(max-width: 792px) 100vw, 792px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png" alt="" class="lazyload wp-image-6839 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1.png 792w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-300x92.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_avantRT-1-768x237.png 768w" data-sizes="(max-width: 792px) 100vw, 792px"><figcaption>Image 2 : Exemple spinlocks avant patch preempt RT</figcaption></figure></div><p>    Maintenant avec le patch PREEMPT_RT, on voit que le scheduler donne la main au thread 2 possédant une priorité plus élevée. Ces changements peuvent être lus sur la documentation de la fondation Linux, on peut voir notamment qu’un spinlock se comporte donc comme un rt_mutex (“<em>In order to minimize the changes to the kernel source the existing spinlock_t datatype and the functions which operate on it retain their old names but, when PREEMPT_RT is enabled, now refer to an rt_mutex lock</em>”) :</p><p><a href="https://wiki.linuxfoundation.org/realtime/documentation/technical_details/sleeping_spinlocks">https://wiki.linuxfoundation.org/realtime/documentation/technical_details/sleeping_spinlocks</a></p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png" alt="" class="wp-image-6841 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png 846w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-300x93.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-768x237.png 768w" sizes="(max-width: 846px) 100vw, 846px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png" alt="" class="lazyload wp-image-6841 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT.png 846w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-300x93.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/spinlock_apresRT-768x237.png 768w" data-sizes="(max-width: 846px) 100vw, 846px"><figcaption>Image 3 : Image 2 : Exemple spinlocks après patch preempt RT</figcaption></figure></div><h3>Raw spinlock</h3><p>    Bien que les spinlocks deviennent des mutex, il reste des endroits dans le kernel où il est nécessaire d’avoir recours à de vrais spinlocks. En effet, certains endroits du kernel ne devraient pas être préemptibles car ils sont vraiment critiques.</p><p>De plus, les spinlocks ont l’avantage d’être plus rapides que les mutex. Pour cela, il existe les raw_spinlocks qui sont en réalité les spinlocks du kernel classique non patché.</p><p>Ils ont été ajoutés au kernel mainline mais ne sont d’aucune utilité dans un kernel non patché. Il faut cependant prendre garde à leur utilisation dans un système temps réel. En effet, les raw_spinlocks désactivent la préemption et les interruptions, ce qui peut engendrer des latences non désirées et donc dégrader l’aspect temps réel du système.</p><h3>Threaded Interrupts</h3><p>    Comme l’objectif du patch PREEMPT_RT est de rendre le kernel aussi préemptible que possible, il paraît normal de modifier le fonctionnement des interruptions. Nous allons tout d’abord revoir le fonctionnement classique des interruptions.</p><p><strong>Interruptions classiques :</strong> Dans le kernel linux, lorsque une interruption survient, c’est à dire lorsqu’un périphérique externe change d’état (des données sur le port ethernet, le changement d’état d’une broche GPIO, etc.), le périphérique envoie un signal au gestionnaire d’interruptions APIC (<em>Advanced Programmable Interrupt Controler</em>).</p><p>Le gestionnaire transmet ensuite une requête d’interruption IRQ (Interrupt Request) au processeur. Ce dernier s’arrête, sauvegarde son contexte puis traite l’interruption concernée. Pour traiter l’interruption, plusieurs méthodes existent, mais la plus courante est celle des top-half et bottom-half.</p><p><strong>Top-half et bottom-half interrupts handler : </strong>Pour traiter une interruption en évitant de monopoliser une unité de calcul, le moyen le plus utilisé est celui des <em>top-half</em> et <em>bottom-half</em>.</p><p>Ce mécanisme consiste à exécuter le top-half au moment de l’interruption, qui effectuera le minimum vital au traitement de l’exécution. Il programmera ensuite dans une file d’exécution un handler <em>bottom-half</em> qui traitera l’interruption proprement une fois qu’elle sera démasquée dans l’APIC et que le processeur disposera de temps de travail disponible.</p><p>Cette méthode permet ainsi de pouvoir gérer une succession rapide d’interruptions vu que le bottom-half est programmé dans tous les cas.</p><p><strong>Threaded interrupts : </strong>Pour permettre au système de gérer des contraintes temps réel, le patch PREEMPT_RT met en place des <em>threaded interrupts</em>.</p><p>Les <em>threaded interrupts</em> reprennent le concept top-half bottom-half, mais remplacent le handler du bottom-half par un thread. Cela permet de donner une priorité au thread et de le préempter si un thread avec une priorité plus élevé est <em>runnable</em>.</p><h3>Héritage de priorité</h3><p>    Le dernier changement important à noter est l’ajout de l’héritage de priorité pour les mutex et les spinlock. Pour illustrer l’héritage de priorité et son importance, regardons le cas suivant.</p><p>Tout d’abord, sans héritage. On peut voir sur le schéma ci-dessous, que le thread 3 possède initialement un mutex. Le thread 1 devenant runnable, commence à exécuter son code jusqu’à ce qu’il demande le mutex tenu par le thread 3, ce qui provoque son endormissement. Le thread 3 reprend alors son exécution. Cependant, avant d’avoir pu relâcher le mutex, le scheduler le préempte en faveur du thread 2 qui s’exécute pour une période indéfinie.</p><p>On constate alors que le thread 1 qui a la priorité la plus élevée ne pourra pas s’exécuter, ce qui par conséquent pose un problème lorsqu’on fait du temps réel du fait que le thread avec la plus grande priorité ne s’exécute pas, on appelle ça une famine.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png" alt="" class="wp-image-6843 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png 843w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-300x164.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-768x420.png 768w" sizes="(max-width: 843px) 100vw, 843px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png" alt="" class="lazyload wp-image-6843 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT.png 843w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-300x164.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_avantRT-768x420.png 768w" data-sizes="(max-width: 843px) 100vw, 843px"><figcaption>Image 4 : Exemple héritage de priorité avant patch preempt RT</figcaption></figure></div><p>Dans ce second exemple avec l’héritage de priorité, on peut voir comme tout à l’heure que le thread 3 possède initialement le mutex. Mais lorsque le thread 1 demande le mutex possédé par le thread 3, le thread 3 hérite de la priorité du thread 1 ce qui lui permet de relâcher le mutex pour permettre au thread 1 de s’exécuter, puis le thread 2 pourra s’exécuter. </p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png" alt="" class="wp-image-6845 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png 830w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-300x174.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-768x445.png 768w" sizes="(max-width: 830px) 100vw, 830px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png" alt="" class="lazyload wp-image-6845 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT.png 830w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-300x174.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/heritage_apresRT-768x445.png 768w" data-sizes="(max-width: 830px) 100vw, 830px"><figcaption>Image 5 : Exemple héritage de priorité après patch preempt RT</figcaption></figure></div><h1>Implémentation du temps réel sur noyau Linux</h1><h2>Les options du noyau Linux </h2><p>    L’implémentation du temps réel sur noyau linux est relativement simple, mais l’obtention de performances optimales est conditionnée à la modification d’options annexes. Durant les phases d’évaluation des différentes solutions temps réel et de leurs performances, nous avons constaté que certaines options impactaient les performances plus que d’autres.</p><h3>Power Management</h3><p>    En contexte temps réel, l’important est d’avoir un système réactif qui puisse réagir à la moindre interruption externe au système. L’activation du power management sur le CPU cause un risque d’augmentation de la latence du CPU. En effet, lorsque le power management est activé, le CPU va adapter sa fréquence pour économiser de l’énergie.</p><p>Cette option reste cependant intéressante lorsque l’on fait de l’embarqué, au vu de la durée des batteries actuelles, mais empêche cependant d’obtenir des performances temps réel. Il peut être intéressant d’utiliser le power management sur certains cœurs (cela peut se faire au moment du boot comme pour les <a href="https://www.linuxembedded.fr/#Timers">timers</a> ci-après) et d’utiliser les autres cœurs pour toutes les tâches temps réels.</p><p>    Pour désactiver le power management, il faut tout d’abord désactiver le multi-core scheduler support. En effet, ce dernier nous empêche de retirer le power management.</p><ul><li>SCHED_MC [=n]</li></ul><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png" alt="" class="wp-image-7019 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png 664w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1-300x84.png 300w" sizes="(max-width: 664px) 100vw, 664px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png" alt="" class="lazyload wp-image-7019 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1.png 664w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num1-1-300x84.png 300w" data-sizes="(max-width: 664px) 100vw, 664px"></figure></div><p>    Une fois le multi-core scheduler support désactivé, on peut maintenant désactiver le CPU Frequency scaling et le CPU Idle. Le CPU Frequency scaling permet de choisir le <em>governor</em> à utiliser pour gérer la fréquence du CPU, ce qui est inutile dans notre cas : nous souhaitons que tous les cœurs tournent à 100% afin de maximiser les performances. En revanche, cela implique une consommation plus élevée. Il se peut, si vous avez un processeur qui supporte l’ACPI, que l’option CPU Idle ne soit pas désactivable, ce que traitera le paragraphe suivant.</p><ul><li>CPU_FREQ [=n]</li><li>CPU_IDLE [=n]</li></ul><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-10.png" alt="" class="wp-image-6832 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d’écran-du-2019-09-09-15-36-10.png 328w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d’écran-du-2019-09-09-15-36-10-300x48.png 300w" sizes="(max-width: 328px) 100vw, 328px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-10.png" alt="" class="lazyload wp-image-6832 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d’écran-du-2019-09-09-15-36-10.png 328w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d’écran-du-2019-09-09-15-36-10-300x48.png 300w" data-sizes="(max-width: 328px) 100vw, 328px"></figure></div><div class="wp-block-image"><figure class="alignleft"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-36.png" alt="" class="wp-image-6833 img-fluid"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-36.png" alt="" class="lazyload wp-image-6833 img-fluid"></figure></div><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-50.png" alt="" class="wp-image-6834 img-fluid"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/Capture-d%E2%80%99%C3%A9cran-du-2019-09-09-15-36-50.png" alt="" class="lazyload wp-image-6834 img-fluid"></figure></div><p>Sur <strong>certains processeurs</strong>, comme ceux d’<strong>intel</strong>, l’ACPI (Advanced Configuration and Power Interface) gère le <em>power management</em>. Il faut donc désactiver l’ACPI seulement pour le processeur, car une désactivation pour d’autres composants pourrait empêcher le système de démarrer correctement. De plus, sa désactivation est un préalable à celle du CPU Idle.</p><ul><li>ACPI_PROCESSOR [=n]</li></ul><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png" alt="" class="wp-image-7020 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png 549w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1-300x150.png 300w" sizes="(max-width: 549px) 100vw, 549px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png" alt="" class="lazyload wp-image-7020 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1.png 549w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num2-1-300x150.png 300w" data-sizes="(max-width: 549px) 100vw, 549px"></figure></div><h3>SMP</h3><p>    Si votre système ne possède qu’un seul cœur, cette section ne vous concerne pas, il faudra donc désactiver cette option.</p><p>Le SMP (Symmetric multi-processing), permet à un système possédant plusieurs cœurs de les utiliser et donc d’exécuter plusieurs tâches à la fois. Le problème de posséder plusieurs cœurs est qu’ils partagent des zones mémoires et notamment de la mémoire cache L2 (cela dépend de l’architecture du processeur). Le fait de partager de la mémoire augmente le temps d’accès à la zone mémoire. Pour éviter ce problème, il est conseillé de bien gérer les affinités des tâches et des processus. Pour activer le multi-processing il suffit de choisir l’option Symmetric multi-processing support.</p><ul><li>SMP [=y]</li></ul><h3 id="Timers">Timers</h3><p>    Ensuite, nous devons paramétrer les timers pour obtenir une plus grande réactivité. Tout d’abord, il faut activer le timer haute résolution qui fournit une meilleure précision pour tous nos programmes user-space.</p><ul><li>HIGH_RES_TIMERS [=y]</li></ul><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png" alt="" class="wp-image-7021 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png 785w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-300x30.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-768x76.png 768w" sizes="(max-width: 785px) 100vw, 785px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png" alt="" class="lazyload wp-image-7021 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1.png 785w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-300x30.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num3-1-768x76.png 768w" data-sizes="(max-width: 785px) 100vw, 785px"></figure></div><p>    Ensuite, pour éviter au système de se mettre en veille, il faut laisser les timers interrompre le système périodiquement afin de ne pas manquer d’événements importants. Il faut donc modifier l’option Timer tick handling comme on peut le voir ci-dessous, et choisir l’option <strong>Periodic timer ticks.</strong> Il peut être intéressant de choisir cette option pour certains cœurs, dans ce cas il faudra donner les options de<em> boot </em>suivantes pour isoler les cœurs et les rendre <em>tickless</em> : <em>« isolcpus=2,3 nohz_full=2,3 »</em></p><ul><li>HZ_PERIODIC [=y]</li></ul><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png" alt="" class="wp-image-7022 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png 618w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1-300x150.png 300w" sizes="(max-width: 618px) 100vw, 618px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png" alt="" class="lazyload wp-image-7022 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1.png 618w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num4-1-300x150.png 300w" data-sizes="(max-width: 618px) 100vw, 618px"></figure></div><hr class="wp-block-separator"><h2>Les impacts sur le développement applicatif et le système</h2><h3>Affinités</h3><p>    Lorsque l’on fait du temps réel sous linux, il est important de gérer l’affinité de ses tâches et des interruptions.</p><p>La première chose à faire, surtout si l’on est en SMP, est de modifier l’affinité des interruptions du système dans /proc/interrupts pour empêcher les migrations de cœur qui augmentent la latence. Il est préférable de regrouper certaines interruptions sur le même CPU pour réserver les autres CPUs à notre application temps réel.</p><p>Pour modifier l’affinité d’une interruption, il faut modifier le pseudo-fichier <em>/proc/irq/<NumeroIRQ>/smp_affinity</em> à l’aide de la commande :<em>« echo 8 > /proc/irq/127/smp_affinity »</em> pour par exemple mettre l’interruption 127 sur le CPU 4. Ce fichier contient en effet un masque binaire définissant le ou les cpus à utiliser en cas d’interruption. Par exemple 0001 représente le CPU 0 tandis que 1001 représente les CPUs 0 et 4. Il est important de noter que le fichier <em>/proc/irq/NumeroIRQ/smp_affinity</em> attend une valeur en hexadécimal, ce qui explique la valeur 8 précédente.</p><p>On peut voir ci-dessous les interruptions et leur nombre d’occurences sur chaque cpu de ma raspberry pi 4 à l’aide de la commande <em>« cat /proc/interrupts »</em>.</p><figure class="wp-block-image"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png" alt="" class="wp-image-7023 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-300x81.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-768x207.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1.png 1032w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png" alt="" class="lazyload wp-image-7023 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-1024x276.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-300x81.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1-768x207.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num5-1.png 1032w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 6 : Résultat de la commande « cat /proc/interrrupts »</figcaption></figure><p>    Lors du développement applicatif d’une solution temps réel, il est important de bien choisir l’affinité de ses threads et de son processus principal. Pour les threads, il existe la fonction <strong><em>pthread_attr_setaffinity_np()</em></strong> et pour le processus principal, on peut utiliser la commande <strong><em>taskset </em></strong>ou la fonction <strong><em>sched_setaffinity(). </em></strong></p><p><strong><em>    </em></strong>Pour vérifier l’utilisation de chaque thread de son programme, on peut utiliser la commande suivante : “<em>watch -n 1 ps -p $(pidof monProgramme) -L -o pid,tid,psr,pcpu,comm</em>”. Cela permet de lister pour un PID donné, tous les threads présents et d’afficher sur quel cœur ils s’exécutent. On peut voir ci-dessous le résultat de cette commande sur un programme personnel.</p><p>La colonne PID représente le PID du programme, le TID celui du thread, PSR indique sur quel cœur le thread s’exécute et %CPU sa consommation CPU. Enfin, la colonne COMMAND permet de connaître le nom du thread si vous avez utilisé la fonction<strong><em> pthread_setname_np()</em></strong>.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png" alt="" class="wp-image-7024 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png 315w,https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6-300x229.png 300w" sizes="(max-width: 315px) 100vw, 315px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png" alt="" class="lazyload wp-image-7024 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6.png 315w, https://www.linuxembedded.fr/wp-content/uploads/2019/10/num6-300x229.png 300w" data-sizes="(max-width: 315px) 100vw, 315px"><figcaption>Image 7 : Résultat de la commande « watch -n 1 ps -p $(pidof cam) -L -o pid,tid,psr,pcpu,comm »</figcaption></figure></div><p>    Il est recommandé de bien connaître l’architecture de son processeur, et d’établir un plan d’affectation des ressources : laisser un cœur pour le système (le coeur 0), et répartir les activités sur les autres cœurs.</p><h3><em>Real Time Throttling</em></h3><p>Lorsque vous exécutez une application temps réel sur un système temps réel, par défaut le système ne donne pas accès à 100% du CPU. En effet, le <em>scheduler</em> temps réel ne permet à un processus que de consommer 95% du temps CPU. Ces paramètres sont régis par les pseudo fichiers suivants :</p><ul><li> <em>/proc/sys/kernel/sched_rt_period_us</em></li><li><em> /proc/sys/kernel/sched_rt_runtime_us</em></li></ul><p>Ces paramètres permettent d’allouer un temps de s<em>ched_rt_runtime_us</em> sur une période de <em>sched_rt_period_us</em>. Par défaut ce ratio vaut <em>950000 µs</em>/100000 <em>µs</em>, soit 95%. Cela permet d’éviter qu’une application erronée ne prenne tout le CPU et empêche le système de réagir à d’autres événements.</p><p>En revanche, il peut être intéressant sur un système validé d’optimiser ce ratio, voire de désactiver cette option en mettant -1 dans <em>/proc/sys/kernel/sched_rt_period_us</em> ou en réglant <em>sched_rt_period_us = sched_rt_runtime_us</em> : <em>« echo -1 > /proc/sys/kernel/sched_rt_period_us »</em>.</p><h1>Performances</h1><p>Afin de mesurer les performances des différentes solutions temps réel, j’ai utilisé les outils suivants : </p><ul><li>Un script lançant des <em>cyclictest</em> avec un ordonnancement<em> </em>SCHED_OTHER, SCHED_RR (round-robin) et SCHED_FIFO avec une priorité de 99, subissant une charge simulée par le programme <em>stress</em>. Chaque test a été joué durant une heure.</li><li>Un programme codé en C calculant le temps de commutation d’un thread à l’autre au moment de lâcher un mutex, sous charge et sans charge, sur même CPU. Chaque test prenant en compte 10000 commutations.</li></ul><p>J’ai réalisé ces tests sur les systèmes suivants :</p><ol><li><strong>x86_64</strong><ol><li><em>Linux vanilla 4.14.71</em></li><li><em>Linux vanilla 4.14.71 PREEMPT_RT</em></li><li><em>Xenomai Cobalt 3.0.8 sous linux vanilla 4.14.71</em></li><li><em>Xenomai Mercury 3.0.8 sous linux vanilla 4.14.71 PREEMPT_RT</em></li></ol></li><li><strong>Raspberry pi 3B, arm 64bits</strong><ol><li><em>Linux rpi 4.14.71</em></li><li><em>Linux rpi 4.14.71 PREEMPT_RT</em></li><li><em>Xenomai Cobalt 3.0.8 sous linux rpi 4.14.71</em></li><li><em>Xenomai Mercury 3.0.8 sous linux rpi 4.14.71 PREEMPT_RT</em></li></ol></li></ol><h3>Cyclictest</h3><p>    Tout au long de cette partie, je ne vais parler que de l’ordonnancement SCHED_FIFO car ses performances sont quasi équivalentes à celles de l’ordonnancement round-robin, et l’ordonnancement SCHED_OTHER ne concerne pas le temps réel.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png" alt="" class="wp-image-6904 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-300x225.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-768x576.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png" alt="" class="lazyload wp-image-6904 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-rpi-1.png 1280w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 8 : Résultats cyclictest sur raspberry pi 3B</figcaption></figure></div><p>    On peut voir sur cette première série de benchmarks les différences entre les différents systèmes. On remarque que seul le kernel linux classique dépasse les 400 µs de latences et que les autres ne dépassent pas les 100 µs. Attention cependant, sur le kernel normal, il y a des pics en dehors du graphique à plus de 10000 µs comme indiqué sur le graphique, ce qui pose donc le problème du déterminisme du système. Avec les trois autres systèmes, le max ne dépasse pas les 100 µs.</p><p>    On peut ensuite voir que les performances sont sensiblement équivalentes entre un système sous Xenomai Mercury et un système patché PREEMPT RT. Enfin la meilleure performance vient du système sous Xenomai Cobalt qui affiche une latence maximale sous les 10 µs avec une moyenne bien plus basse que les 2 autres, <strong><em>et les latences semblent mieux bornées.</em></strong></p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png" alt="" class="wp-image-6905 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-300x225.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-768x576.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png" alt="" class="lazyload wp-image-6905 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/fifo-x86_64-1.png 1280w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 9 : Résultats cyclictest sur x86_64</figcaption></figure></div><p>    Passons maintenant sous x86_64, on peut voir que le même ordre est respecté, sauf pour Xenomai Mercury qui présente de moins bonnes performances que ses concurrents. Comme tout à l’heure le test sous linux 4.14.71 non préemptible révèle des pics à plus de 10000 µs comme indiqué sur le graphique qui sortent de la porté du graphique.</p><h3>Commutations de threads</h3><p>    Afin de mesurer les performances de commutations, j’ai codé un petit programme qui calcule le temps que met le cpu pour changer de thread. Le principe du programme est le suivant : le thread 1 prend un mutex, puis le relâche. Le scheduler est appelé et le thread 2 se lance en prenant le mutex. Le temps séparant la fin du thread 1 du début du thread 2 est mesuré et stocké dans une variable globale protégée par le mutex. Au bout de 10000 mesures, le résultat est affiché.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png" alt="" class="wp-image-6861 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png 620w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation-300x120.png 300w" sizes="(max-width: 620px) 100vw, 620px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png" alt="" class="lazyload wp-image-6861 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation.png 620w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/tempsCommutation-300x120.png 300w" data-sizes="(max-width: 620px) 100vw, 620px"><figcaption>Image 10 : Exemple temps de commutations entre deux threads</figcaption></figure></div><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png" alt="" class="wp-image-6868 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-300x225.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-768x576.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png" alt="" class="lazyload wp-image-6868 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-Rpi-stress.png 1600w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 11 : Résultats commutations de threads sur raspberry pi 3B</figcaption></figure></div><p>    Les résultats ci-dessus montrent les différences de performances sur Raspberry Pi sous stress. On peut voir que les performances entre un linux non patché et patché PREEMPT_RT sont assez similaires, avec une valeur max de 90 µs. En revanche on peut voir un résultat assez étrange : les moins bonnes performances sont atteintes par Xenomai Mercury. Enfin, Xenomai Cobalt obtient les meilleures performances.</p><div class="wp-block-image"><figure class="aligncenter"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png" alt="" class="wp-image-6869 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-300x225.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-768x576.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png" alt="" class="lazyload wp-image-6869 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-1024x768.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-300x225.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress-768x576.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-x86_64-stress.png 1600w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 12 : Résultats commutations de threads sur x86_64</figcaption></figure></div><p>    Passons maintenant sur x86_64, nous observons sensiblement les mêmes résultats que sur arm64, avec toujours un retard de performance pour Xenomai Mercury.</p><h3>Différences entre POSIX et Alchemy (Xenomai)</h3><p>    Xenomai propose des skins, qui sont de petits wrappers permettant d’utiliser des APIs venant d’autres systèmes comme VxWorks ou POSIX avec Xenomai. La librairie native à xenomai est la librairie Alchemy qui est assez complète et fournit des outils très utiles comme des queues optimisées, des buffers, des pipes, des sémaphores etc…</p><p>    Nous allons voir la différence de performance entre les deux skins POSIX et Alchemy, grâce à un portage du programme réalisé pour la commutation de threads sous les deux librairies. Voici ci-dessous les performances sous Xenomai Mercury. On peut voir un petit gain de performance avec la librairie native.</p><figure class="wp-block-image"><noscript><img src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png" alt="" class="wp-image-6870 img-fluid" srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png 1024w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-300x113.png 300w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-768x288.png 768w,https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20%20%22%3E%3C/svg%3E" data-src="http://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png" alt="" class="lazyload wp-image-6870 img-fluid" data-srcset="https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-1024x384.png 1024w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-300x113.png 300w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy-768x288.png 768w, https://www.linuxembedded.fr/wp-content/uploads/2019/09/plot-mutex-posixvsalchemy.png 1600w" data-sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Image 13 : Résultats commutations de threads sur raspberry pi 3B, différences APIs POSIX vs Alchemy</figcaption></figure><h1> Conclusion</h1><p>    Pour conclure, nous constatons avec évidence que Xenomai Cobalt est la meilleure des solutions pour faire du Linux temps réel avec des contraintes hard real time. Cependant, nous pouvons voir que le patch PREEMPT_RT propose une solution plus facile à mettre en place que Xenomai et présente de très bonnes caractéristiques temps réel, qui ont vu une nette amélioration récemment.</p><p>    On remarque par contre des résultats un peu étonnants sur Xenomai Mercury qui affiche des performances plus faibles que ses concurrents. Encore une fois, les tests réalisés ne sont pas précis à 100% au vu de leur durée et du nombre de tests réalisés, en raison d’un manque de temps.</p><p>Pour ce qui est de Xenomai et comment l’implémenter de manière optimale, voici en lien le wiki de Xenomai qui est très bien documenté :</p><p><a href="https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here">https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here</a></p><p>    De plus, j’ai exposé ici quelques options à activer/désactiver au niveau du kernel, mais la configuration optimale dépendra de l’architecture utilisée et des contraintes liées au produit. Si vous êtes intéressé, vous pouvez consulter le site ci-dessous décrivant toutes les subtilités et les améliorations à faire pour mettre en place du temps réel :</p><p><a href="http://linuxrealtime.org/index.php/Main_Page">http://linuxrealtime.org/index.php/Main_Page</a></p><p>    Je vous partage également deux vidéos intéressantes sur le patch PREEMPT_RT :</p><ul><li><em>Real Time is Coming to Linux; What Does that Mean to You? – Steven Rostedt, VMware</em></li></ul><figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper"> <iframe title="Real Time is Coming to Linux; What Does that Mean to You? - Steven Rostedt, VMware" width="1170" height="658" src="https://www.youtube.com/embed/BxJm-Ujipcg?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></figure><ul><li><em>Embedded Linux Conference 2013 – Inside the RT Patch </em></li></ul><figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper"> <iframe title="Embedded Linux Conference 2013 - Inside the RT Patch" width="1170" height="658" src="https://www.youtube.com/embed/n9ucTGWrON8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></figure><ul><li><em>Introduction to Realtime Linux</em></li></ul><figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper"> <iframe title="Introduction to Realtime Linux" width="1170" height="658" src="https://www.youtube.com/embed/BKkX9WASfpI?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></figure></div></div><div class="clearfix"></div></article><nav class="navigation post-navigation" role="navigation" aria-label="Articles"><h2 class="screen-reader-text">Navigation de l'article</h2><div class="nav-links"><div class="nav-previous"><a href="https://dev-pro.xyz/blog/my-first-linux-kernel-built-with-clang-compiler/" rel="prev"><i class="fa fa-angle-double-left" aria-hidden="true"></i> My first Linux kernel built with Clang compiler!</a></div><div class="nav-next"><a href="https://dev-pro.xyz/blog/flamegraph/" rel="next">FlameGraph <i class="fa fa-angle-double-right" aria-hidden="true"></i></a></div></div></nav></div></div><div class="col-md-12 col-lg-3 ml-auto"><div class="sidebar my-5"><aside id="recent-posts-2" class="widget widget_recent_entries mb-5"><h3 class="widget-title mt-0">Articles récents</h3><ul><li> <a href="https://dev-pro.xyz/blog/storing-crash-data-of-the-linux-kernel-for-post-crash-debugging/">Storing crash data of the Linux kernel for post-crash debugging</a></li><li> <a href="https://dev-pro.xyz/blog/gestion-de-versions-des-bibliotheques-partagees/">Gestion de versions des bibliothèques partagées</a></li><li> <a href="https://dev-pro.xyz/blog/flamegraph/">FlameGraph</a></li><li> <a href="https://dev-pro.xyz/blog/le-temps-reel-sous-linux/" aria-current="page">Le Temps Reel sous Linux</a></li><li> <a href="https://dev-pro.xyz/blog/my-first-linux-kernel-built-with-clang-compiler/">My first Linux kernel built with Clang compiler!</a></li></ul></aside><aside id="categories-3" class="widget widget_categories mb-5"><h3 class="widget-title mt-0">Catégories</h3><ul><li class="cat-item cat-item-137"><a href="https://dev-pro.xyz/blog/category/actu-linux/" title="Auto Added by WPeMatico">Actu Linux</a></li><li class="cat-item cat-item-145"><a href="https://dev-pro.xyz/blog/category/actualite-mobiles-et-tablettes/" title="Auto Added by WPeMatico">Actualité Mobiles et Tablettes</a></li><li class="cat-item cat-item-143"><a href="https://dev-pro.xyz/blog/category/actualite-windows-os-x-et-linux/" title="Auto Added by WPeMatico">Actualité Windows, OS X et Linux</a></li><li class="cat-item cat-item-151"><a href="https://dev-pro.xyz/blog/category/apple/" title="Auto Added by WPeMatico">Apple</a></li><li class="cat-item cat-item-161"><a href="https://dev-pro.xyz/blog/category/clang/" title="Auto Added by WPeMatico">clang</a></li><li class="cat-item cat-item-174"><a href="https://dev-pro.xyz/blog/category/crash/" title="Auto Added by WPeMatico">crash</a></li><li class="cat-item cat-item-175"><a href="https://dev-pro.xyz/blog/category/crashdump/" title="Auto Added by WPeMatico">crashdump</a></li><li class="cat-item cat-item-169"><a href="https://dev-pro.xyz/blog/category/debug/" title="Auto Added by WPeMatico">debug</a></li><li class="cat-item cat-item-138"><a href="https://dev-pro.xyz/blog/category/distribution-linux/" title="Auto Added by WPeMatico">Distribution Linux</a></li><li class="cat-item cat-item-152"><a href="https://dev-pro.xyz/blog/category/ecouteurs/" title="Auto Added by WPeMatico">Ecouteurs</a></li><li class="cat-item cat-item-158"><a href="https://dev-pro.xyz/blog/category/europe/" title="Auto Added by WPeMatico">Europe</a></li><li class="cat-item cat-item-146"><a href="https://dev-pro.xyz/blog/category/fcc/" title="Auto Added by WPeMatico">FCC</a></li><li class="cat-item cat-item-154"><a href="https://dev-pro.xyz/blog/category/film/" title="Auto Added by WPeMatico">Film</a></li><li class="cat-item cat-item-153"><a href="https://dev-pro.xyz/blog/category/geekeries-et-insolite/" title="Auto Added by WPeMatico">Geekeries et Insolite</a></li><li class="cat-item cat-item-157"><a href="https://dev-pro.xyz/blog/category/hors-sujet/" title="Auto Added by WPeMatico">Hors-Sujet</a></li><li class="cat-item cat-item-160"><a href="https://dev-pro.xyz/blog/category/howto/" title="Auto Added by WPeMatico">HowTo</a></li><li class="cat-item cat-item-147"><a href="https://dev-pro.xyz/blog/category/huawei/" title="Auto Added by WPeMatico">Huawei</a></li><li class="cat-item cat-item-139"><a href="https://dev-pro.xyz/blog/category/info-version/" title="Auto Added by WPeMatico">Info version</a></li><li class="cat-item cat-item-129"><a href="https://dev-pro.xyz/blog/category/installation-logiciel-linux/" title="Auto Added by WPeMatico">Installation Logiciel Linux</a></li><li class="cat-item cat-item-148"><a href="https://dev-pro.xyz/blog/category/justice/" title="Auto Added by WPeMatico">Justice</a></li><li class="cat-item cat-item-162"><a href="https://dev-pro.xyz/blog/category/kernel/" title="Auto Added by WPeMatico">kernel</a></li><li class="cat-item cat-item-176"><a href="https://dev-pro.xyz/blog/category/kexec/" title="Auto Added by WPeMatico">kexec</a></li><li class="cat-item cat-item-171"><a href="https://dev-pro.xyz/blog/category/libc/" title="Auto Added by WPeMatico">libc</a></li><li class="cat-item cat-item-172"><a href="https://dev-pro.xyz/blog/category/linker/" title="Auto Added by WPeMatico">linker</a></li><li class="cat-item cat-item-163"><a href="https://dev-pro.xyz/blog/category/linux/" title="Auto Added by WPeMatico">Linux</a></li><li class="cat-item cat-item-130"><a href="https://dev-pro.xyz/blog/category/linux-mint/" title="Auto Added by WPeMatico">Linux Mint</a></li><li class="cat-item cat-item-140"><a href="https://dev-pro.xyz/blog/category/linux-mint-19-3/" title="Auto Added by WPeMatico">Linux Mint 19.3</a></li><li class="cat-item cat-item-131"><a href="https://dev-pro.xyz/blog/category/machine-virtuelle/" title="Auto Added by WPeMatico">Machine virtuelle</a></li><li class="cat-item cat-item-150"><a href="https://dev-pro.xyz/blog/category/materiel-et-accessoires/" title="Auto Added by WPeMatico">Matériel et Accessoires</a></li><li class="cat-item cat-item-134"><a href="https://dev-pro.xyz/blog/category/messagerie-instantanee/" title="Auto Added by WPeMatico">Messagerie instantanée</a></li><li class="cat-item cat-item-63"><a href="https://dev-pro.xyz/blog/category/microsoft/" title="Auto Added by WPeMatico">Microsoft</a></li><li class="cat-item cat-item-141"><a href="https://dev-pro.xyz/blog/category/mise-a-niveau-linux/" title="Auto Added by WPeMatico">Mise à niveau Linux</a></li><li class="cat-item cat-item-142"><a href="https://dev-pro.xyz/blog/category/mise-a-niveau-linux-mint/" title="Auto Added by WPeMatico">Mise à niveau Linux Mint</a></li><li class="cat-item cat-item-170"><a href="https://dev-pro.xyz/blog/category/perf/" title="Auto Added by WPeMatico">perf</a></li><li class="cat-item cat-item-166"><a href="https://dev-pro.xyz/blog/category/preempt-rt/" title="Auto Added by WPeMatico">preempt-rt</a></li><li class="cat-item cat-item-76"><a href="https://dev-pro.xyz/blog/category/reseaux/" title="Auto Added by WPeMatico">Réseaux</a></li><li class="cat-item cat-item-159"><a href="https://dev-pro.xyz/blog/category/samsung/" title="Auto Added by WPeMatico">Samsung</a></li><li class="cat-item cat-item-135"><a href="https://dev-pro.xyz/blog/category/skype/" title="Auto Added by WPeMatico">Skype</a></li><li class="cat-item cat-item-155"><a href="https://dev-pro.xyz/blog/category/sonic/" title="Auto Added by WPeMatico">Sonic</a></li><li class="cat-item cat-item-173"><a href="https://dev-pro.xyz/blog/category/symboles/" title="Auto Added by WPeMatico">symboles</a></li><li class="cat-item cat-item-164"><a href="https://dev-pro.xyz/blog/category/technologie/" title="Auto Added by WPeMatico">Technologie</a></li><li class="cat-item cat-item-167"><a href="https://dev-pro.xyz/blog/category/temps-reel/" title="Auto Added by WPeMatico">temps réel</a></li><li class="cat-item cat-item-156"><a href="https://dev-pro.xyz/blog/category/trailer/" title="Auto Added by WPeMatico">Trailer</a></li><li class="cat-item cat-item-127"><a href="https://dev-pro.xyz/blog/category/tuto-linux-mint/" title="Auto Added by WPeMatico">Tuto Linux Mint</a></li><li class="cat-item cat-item-128"><a href="https://dev-pro.xyz/blog/category/tuto-ubuntu/" title="Auto Added by WPeMatico">Tuto Ubuntu</a></li><li class="cat-item cat-item-136"><a href="https://dev-pro.xyz/blog/category/tuto-virtualbox/" title="Auto Added by WPeMatico">Tuto VirtualBox</a></li><li class="cat-item cat-item-132"><a href="https://dev-pro.xyz/blog/category/ubuntu/" title="Auto Added by WPeMatico">Ubuntu</a></li><li class="cat-item cat-item-1"><a href="https://dev-pro.xyz/blog/category/uncategorized/">Uncategorized</a></li><li class="cat-item cat-item-149"><a href="https://dev-pro.xyz/blog/category/usa/" title="Auto Added by WPeMatico">USA</a></li><li class="cat-item cat-item-133"><a href="https://dev-pro.xyz/blog/category/virtualbox/" title="Auto Added by WPeMatico">Virtualbox</a></li><li class="cat-item cat-item-177"><a href="https://dev-pro.xyz/blog/category/vmcore/" title="Auto Added by WPeMatico">vmcore</a></li><li class="cat-item cat-item-165"><a href="https://dev-pro.xyz/blog/category/whitepaper/" title="Auto Added by WPeMatico">WhitePaper</a></li><li class="cat-item cat-item-144"><a href="https://dev-pro.xyz/blog/category/windows-10/" title="Auto Added by WPeMatico">Windows 10</a></li><li class="cat-item cat-item-168"><a href="https://dev-pro.xyz/blog/category/xenomai/" title="Auto Added by WPeMatico">Xenomai</a></li></ul></aside></div></div></div></div><footer class="page-footer text-light"><div class="container"><div class="row"><div class="col-md-12"><div class="social-icons my-5 py-7 d-flex justify-content-center"></div></div></div></div><div class="footer-copyright text-center small bg-dimped__dark py-3"> <a class="text-light" href="">© 2019</a> <span class="sep text-light mx-2"> | </span> <a class="text-light" href="https://dev-pro.xyz/">Dev-Pro</a></div></footer></div> <noscript><style>.lazyload{display:none;}</style></noscript><script data-noptimize="1">window.lazySizesConfig=window.lazySizesConfig||{};window.lazySizesConfig.loadMode=1;</script><script async data-noptimize="1" src="https://dev-pro.xyz/blog/wp-content/plugins/autoptimize/classes/external/js/lazysizes.min.js"></script><script defer src="https://dev-pro.xyz/blog/wp-content/cache/autoptimize/js/autoptimize_430637a5ce5bae584155bf0968bdd4d3.js"></script></body></html>
